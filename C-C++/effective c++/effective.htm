<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3c.org/TR/1999/REC-html401-19991224/loose.dtd">
<!-- saved from url=(0051)http://blog.csdn.net/shenzi/article/details/5601038 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><HTML 
xmlns="http://www.w3.org/1999/xhtml"><HEAD><!--AdForward Begin:-->
<SCRIPT type="text/javascript" charset="gbk" src="effective_files/AllyesDeliver.min.js" ads-src="http://csdnim.allyes.com/main/s?user=allyestest|allyestest|allyestest0410&amp;db=csdnim&amp;border=0&amp;local=yes&amp;js=ie"></SCRIPT>
<!--AdForward End--><!--AdForward Begin:-->
<SCRIPT type="text/javascript" charset="gbk" src="effective_files/AllyesDeliver.min.js" ads-src="http://csdnim.allyes.com/main/s?user=csdn|homepage|floating_1&amp;db=csdnim&amp;border=0&amp;local=yes&amp;js=ie"></SCRIPT>
<!--AdForward End--><!--AdForward Begin:-->
<SCRIPT type="text/javascript" charset="gbk" src="effective_files/AllyesDeliver.min.js" ads-src="http://csdnim.allyes.com/main/s?user=csdn|homepage|WebIM_1&amp;db=csdnim&amp;border=0&amp;local=yes&amp;js=ie"></SCRIPT>
<!--AdForward End-->
<SCRIPT type="text/javascript" charset="utf-8" src="effective_files/tracking.js"></SCRIPT>

<SCRIPT type="text/javascript">
        var protocol = window.location.protocol;
        document.write('<script type="text/javascript" src="' + protocol + '//csdnimg.cn/pubfooter/js/repoAddr2.js?v=' + Math.random() + '"></' + 'script>');
    </SCRIPT>

<SCRIPT id="allmobilize" charset="utf-8" src="effective_files/allmobilize.min.js"></SCRIPT>

<META content="no-siteapp" http-equiv="Cache-Control"><LINK rel="alternate" 
href="#" media="handheld"><TITLE>Effective C++读书笔记 - shenzi的天空        - 博客频道 - 
CSDN.NET</TITLE>
<META content="text/html; charset=utf-8" http-equiv="Content-Type">
<META name="description" content="&nbsp;记得前段时间又一次拿起《Effective C++》的时候，有种豁然开朗的感觉，所以翻出了我第一遍读时做的笔记。只做参考以及查阅之用。如有需要请参阅《Effective C++》书本。 by shenzi/2010.5.17一.让自己习惯C++&nbsp;&nbsp; 条款01：视C++为一个语言联邦&nbsp;&nbsp;&nbsp; 为了更好的理解C++，我们将C++分解为四个主要次语言：C。说到底C++仍是以C">
<SCRIPT type="text/javascript" src="effective_files/jquery.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/ad.js"></SCRIPT>
<!--new top--><LINK rel="stylesheet" href="effective_files/index.css"><!--new top--><LINK 
rel="Stylesheet" type="text/css" href="effective_files/style.css"><LINK id="RSSLink" 
title="RSS" rel="alternate" type="application/rss+xml" 
href="/shenzi/rss/list"><LINK rel="shortcut icon" href="http://c.csdnimg.cn/public/favicon.ico"><LINK 
rel="stylesheet" type="text/css" href="effective_files/default.css">
<META name="GENERATOR" content="MSHTML 9.00.8112.16644"></HEAD>
<BODY><!--new top-->
<SCRIPT id="toolbar-tpl-scriptId" type="text/javascript" src="effective_files/html.js" skin="black" prod="blog" fixed="true"></SCRIPT>
<!--new top-->
<DIV id="container">
<DIV id="header">
<DIV class="header">
<DIV id="blog_title">
<H2><A href="http://blog.csdn.net/shenzi">shenzi的天空</A></H2>
<H3>当你有个锤子的时候，什么东西看起来都像是钉子！寻找自己的锤子。</H3>
<DIV class="clear"></DIV></DIV>
<DIV class="clear"></DIV></DIV></DIV>
<DIV id="navigator">
<DIV class="navigator_bg"></DIV>
<DIV class="navigator">
<UL>
  <LI id="btnContents"><A 
  href="http://blog.csdn.net/shenzi?viewmode=contents"><SPAN onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_mulu'])"><IMG 
  src="effective_files/ico_list.gif">目录视图</SPAN></A></LI>
  <LI id="btnView"><A href="http://blog.csdn.net/shenzi?viewmode=list"><SPAN 
  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_zhaiyao'])"><IMG 
  src="effective_files/ico_summary.gif">摘要视图</SPAN></A></LI>
  <LI id="btnRss"><A href="http://blog.csdn.net/shenzi/rss/list"><SPAN onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_RSS'])"><IMG 
  src="effective_files/ico_rss.gif">订阅</SPAN></A></LI></UL></DIV></DIV>
<SCRIPT type="text/javascript">var username = "shenzi";
    var _blogger = username;
    var blog_address = "http://blog.csdn.net/shenzi";
    var static_host = "http://static.blog.csdn.net";
    var currentUserName = "";  
</SCRIPT>

<DIV id="body">
<DIV id="main">
<DIV class="main">
<DIV class="ad_class">
<DIV class="notice tracking-ad" data-mod="popu_3"><A href="http://vote.blog.csdn.net/">
<FONT color="blue">Markdown那么好，还不来试试</FONT></A>&nbsp;&nbsp;&nbsp;<A href="http://blog.csdn.net/blogdevteam/article/details/45846519">
<FONT color="red">扒一扒你遇到过最NB开发项目</FONT></A>&nbsp;&nbsp;&nbsp;<A href="http://bbs.csdn.net/topics/391037747">
<FONT color="blue">5月问答又送C币咯！</FONT></A>&nbsp;&nbsp;&nbsp;<A href="http://huiyi.csdn.net/activity/product/goods_list?project_id=1951">
<FONT color="red">Hadoop实战高手速成宝典</FONT></A>&nbsp;&nbsp;&nbsp;</DIV></DIV><LINK 
rel="stylesheet" type="text/css" href="effective_files/comment1.css"><LINK rel="stylesheet" 
type="text/css" href="effective_files/style1.css">
<SCRIPT language="JavaScript" type="text/javascript" src="effective_files/jquery.cookie.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/main.js"></SCRIPT>
<LINK rel="stylesheet" href="effective_files/markdown_views.css">
<SCRIPT type="text/javascript" src="effective_files/MathJax.js"></SCRIPT>

<SCRIPT type="text/ecmascript">
      window.quickReplyflag = true;
    </SCRIPT>

<DIV id="article_details" class="details">
<DIV class="article_title"><SPAN class="ico ico_type_Original"></SPAN>
<H1><SPAN class="link_title"><A href="http://blog.csdn.net/shenzi/article/details/5601038"> 
       Effective C++读书笔记        </A></SPAN></H1></DIV>
<DIV class="article_manage"><SPAN class="link_categories">        分类：            
<A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_fenlei']);" 
href="http://blog.csdn.net/shenzi/article/category/483047">C++</A></SPAN><SPAN 
class="link_postdate">2010-05-17 16:29</SPAN><SPAN class="link_view" title="阅读次数">6707人阅读</SPAN><SPAN 
class="link_comments" title="评论次数"><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_pinglun'])" 
href="http://blog.csdn.net/shenzi/article/details/5601038#comments">评论</A>(3)</SPAN><SPAN 
class="link_collect"><A title="收藏" onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shoucang']);collectArticle('Effective C++读书笔记','5601038');return false;" 
href="javascript:void(0);">收藏</A></SPAN><SPAN class="link_report"><A title="举报" 
onclick="javascript:_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_jubao']);report(5601038,2);return false;" 
href="http://blog.csdn.net/shenzi/article/details/5601038#report">举报</A></SPAN></DIV>
<DIV class="tag2box"><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);" 
href="http://www.csdn.net/tag/%e8%af%bb%e4%b9%a6" target="_blank">读书</A><A 
onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);" 
href="http://www.csdn.net/tag/c%2b%2b" target="_blank">c++</A><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);" 
href="http://www.csdn.net/tag/%e7%bc%96%e8%af%91%e5%99%a8" 
target="_blank">编译器</A><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);" 
href="http://www.csdn.net/tag/delete" target="_blank">delete</A><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);" 
href="http://www.csdn.net/tag/raii" target="_blank">raii</A><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_tag']);" 
href="http://www.csdn.net/tag/reference" target="_blank">reference</A></DIV>
<DIV id="article_content" class="article_content">
<DIV id="google_header" class="google_header">
<P>&nbsp;<SPAN 
style="color: rgb(56, 118, 29); font-size: small;">记得前段时间又一次拿起《Effective 
C++》的时候，有种豁然开朗的感觉，所以翻出了我第一遍读时做的笔记。只做参考以及查阅之用。如有需要请参阅《Effective C++》书本。 by 
shenzi/2010.5.17</SPAN></P></DIV>
<DIV><STRONG><SPAN style="color: rgb(0, 0, 255); font-size: large;"><SPAN style="font-family: verdana;">一.让自己习惯C++</SPAN></SPAN></STRONG><BR>
<HR SIZE="2">
&nbsp;&nbsp; <SPAN style="font-size: medium;"><SPAN 
style="font-size: large;"><STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款01：视C++为一个语言联邦</SPAN></STRONG></SPAN><BR>&nbsp;&nbsp;&nbsp; 
为了更好的理解C++，我们将C++分解为四个主要次语言：<BR></SPAN>
<UL>
  <LI><SPAN style="font-size: medium;"><SPAN 
  style="color: rgb(255, 0, 0);">C</SPAN>。说到底C++仍是以C为基础。区块，语句，预处理器，内置数据类型，数组，指针统统来自C。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;"><SPAN 
  style="color: rgb(255, 0, 0);">Object-Oreinted 
  C++</SPAN>。这一部分是面向对象设计之古典守则在C++上的最直接实施。类，封装，继承，多态，virtual函数等等...</SPAN> </LI>
  <LI><SPAN style="font-size: medium;"><SPAN 
  style="color: rgb(255, 0, 0);">Template C++</SPAN>。这是C++泛型编程部分。</SPAN> </LI>
  <LI><SPAN style="font-size: medium;"><SPAN 
  style="color: rgb(255, 0, 0);">STL</SPAN>。STL是个template程序库。容器（containers），迭代器（iterators），算法（algorithms）以及函数对象（function 
  objects）...</SPAN></LI></UL>&nbsp;&nbsp; <SPAN style="color: rgb(0, 0, 0); font-size: medium; background-color: rgb(207, 226, 243);"><STRONG 
style="color: rgb(255, 0, 0); background-color: rgb(255, 255, 255);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN style="color: rgb(0, 0, 0); font-size: medium; background-color: rgb(207, 226, 243);"><SPAN 
  style="background-color: rgb(255, 255, 255);">这四个次语言，当你从某个次语言切换到另一个，导致高效编程守则要求你改变策略。C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。</SPAN></SPAN></LI>
</UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <SPAN style="font-size: large;"><STRONG><SPAN style="color: rgb(204, 0, 0);">条款02：尽量以const，enum，inline替换#define</SPAN></STRONG></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">这个条款或许可以改为“宁可 以编译器替换预处理器”。即尽量少用预处理。</SPAN><BR>
<P style="color: rgb(0, 1, 2);">&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(11, 83, 148); font-size: medium;">编译过程：</SPAN><SPAN 
style="color: rgb(11, 83, 148); font-family: 文鼎PL细上海宋Uni, serif; font-size: medium;">.c</SPAN><SPAN 
style="color: rgb(11, 83, 148); font-size: medium;">文件－－预处理－－</SPAN><SPAN style="color: rgb(11, 83, 148); font-family: 文鼎PL细上海宋Uni, serif; font-size: medium;">&gt;.i</SPAN><SPAN 
style="color: rgb(11, 83, 148); font-size: medium;">文件－－编译</SPAN><SPAN style="color: rgb(11, 83, 148); font-family: 文鼎PL细上海宋Uni, serif; font-size: medium;">-－&gt;.o</SPAN><SPAN 
style="color: rgb(11, 83, 148); font-size: medium;">文件－</SPAN><SPAN style="color: rgb(11, 83, 148); font-family: 文鼎PL细上海宋Uni, serif; font-size: medium;">-</SPAN><SPAN 
style="color: rgb(11, 83, 148); font-size: medium;">链接－－</SPAN><SPAN style="color: rgb(11, 83, 148); font-family: 文鼎PL细上海宋Uni, serif; font-size: medium;">&gt;bin</SPAN><SPAN 
style="color: rgb(11, 83, 148); font-size: medium;">文件</SPAN></P>
<P style="color: rgb(0, 1, 2);"><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp; 
预处理过程扫描源代码，对其进行初步的转换，产生新的源代码提供给编译器。检查包含预处理指令的语句和宏定义，并对源代码进行相应的转换。</SPAN><SPAN 
style="font-size: medium;">预处理过程还会删除程序中的注释和多余的空白字符。</SPAN><SPAN style="font-size: medium;">可见预处理过程先于编译器对源代码进行处理。</SPAN><SPAN 
style="font-size: medium;">预处理指令是以#号开头的代码行。</SPAN></P>
<P style="color: rgb(0, 1, 2);"><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp; <SPAN style="color: rgb(255, 0, 0);">例：#define <SPAN style="color: rgb(0, 0, 0);">ASPECT_RATIO 
1.653</SPAN></SPAN></SPAN></P>
<P style="color: rgb(0, 1, 2);"><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp; 
记号名称ASPECT_RATIO也许从未被编译器看见，也许在编译器开始处理源代码之前它就被预处理器移走了。即编译源代码时ASPECT_RATIO已被1.653取代。ASPECT_RATIO可能并未进入记号表（symbol 
table）。</SPAN></P>
<P style="color: rgb(0, 1, 2);"><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp; <SPAN style="color: rgb(255, 0, 0);">替换：const<SPAN style="color: rgb(0, 0, 0);"> 
double AspectRatio = 1.653；</SPAN></SPAN></SPAN></P>
<P style="color: rgb(0, 1, 2);"><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp; <SPAN 
style="color: rgb(0, 0, 0); background-color: rgb(207, 226, 243);">好处应该有：多了类型检查，因为#define 
只是单纯的替换，而这种替换在目标码中可能出现多份1.653；改用常量绝不会出现相同情况。</SPAN><BR></SPAN></P>
&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">常量替换#define两点注意：</SPAN><BR>
<UL>
  <LI><SPAN style="font-size: medium;">定义常量指针：</SPAN></LI></UL>&nbsp;&nbsp; &nbsp; 
<SPAN style="color: rgb(0, 0, 0); font-size: medium;"><SPAN style="color: rgb(255, 0, 0);">const</SPAN> 
char *authorName = “Shenzi”；<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0);">cosnt 
</SPAN>std::string authorName("Shenzi");</SPAN><BR>
<UL>
  <LI><SPAN style="font-size: medium;">类专属常量：</SPAN></LI></UL></DIV>
<P>&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0); font-size: medium;">static 
const<SPAN style="color: rgb(0, 0, 0);"> int NumTurns = 5；//static 静态常量 
所有的对象只有一份拷贝。</SPAN></SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="font-size: medium;">万一你编译器<SPAN 
style="color: rgb(255, 0, 0);">不允许</SPAN>“static整数型class常量”完成“in 
calss初值设定”（即在类的声明中设定静态整形的初值），我们可以通过枚举类型予以补偿：<BR>&nbsp;&nbsp; &nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">enum <SPAN style="color: rgb(0, 0, 0);">{ 
NumTurns = 5 }；</SPAN></SPAN><BR></SPAN>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium; background-color: rgb(207, 226, 243);">*取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。如果你不想让别人获取一个pointer或reference指向你的某个整数常量，enum可以帮助你实现这个约束。<BR><SPAN 
style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0);">例：#define 
<SPAN style="color: rgb(0, 0, 0);">CALL_WITH_MAX(a,b)&nbsp;&nbsp;&nbsp; f((a) 
&gt; (b)) ? (a) : (b))</SPAN></SPAN><BR>&nbsp;&nbsp; &nbsp; 
宏看起来像函数，但不会招致函数调用带来的额外开销，而是一种简单的替换。<BR>&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0);">替换：</SPAN><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;<SPAN style="color: rgb(0, 0, 0);">template&lt;typename 
T&gt;</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0);">inline 
</SPAN>void callWithMax(cosnt T &amp;a, cosnt T &amp;b)</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp; &nbsp;&nbsp; {</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; f(a &gt; b ? a : b);</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;}</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp; 
</SPAN></SPAN><SPAN style="font-size: medium; background-color: rgb(207, 226, 243);"><SPAN 
style="background-color: rgb(255, 255, 255);">callWithMax</SPAN></SPAN><SPAN 
style="font-size: medium; background-color: rgb(207, 226, 243);"><SPAN style="background-color: rgb(255, 255, 255);"><SPAN 
style="color: rgb(0, 0, 0);">是个真正的函数，它遵循作用于和访问规则。<BR>&nbsp;&nbsp; &nbsp;&nbsp; 
<STRONG style="background-color: rgb(255, 255, 255);"><SPAN style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR 
style="background-color: rgb(255, 255, 255);"></SPAN></SPAN></SPAN></P>
<UL>
  <LI style="background-color: rgb(255, 255, 255);"><SPAN style="font-size: medium; background-color: rgb(207, 226, 243);"><SPAN 
  style="color: rgb(0, 0, 0);"><SPAN style="background-color: rgb(255, 255, 255);">对于单纯常量，最好以const对象或enums替换#defines；</SPAN></SPAN></SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium; background-color: rgb(207, 226, 243);"><SPAN style="background-color: rgb(255, 255, 255);"><SPAN 
  style="color: rgb(0, 0, 0);"><SPAN style="background-color: rgb(255, 255, 255);">对于形似函数的宏，最好改用inline函数替换#defines。 
  &nbsp; &nbsp; </SPAN>&nbsp;&nbsp; <BR></SPAN></SPAN></SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款03：尽可能使用const</SPAN><BR style="color: rgb(204, 0, 0);"></STRONG>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">const允许你告诉编译器和其他程序员某值应保持不变，只要“某值”确实是不该被改变的，那就该确实说出来。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">关键字const多才多艺：</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><SPAN 
style="color: rgb(255, 0, 0);">例：</SPAN><BR 
style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;<SPAN style="color: rgb(0, 0, 0);"> 
&nbsp;char greeting[] = "Hello";</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;char *p = 
greeting;&nbsp;&nbsp;&nbsp; //指针p及所指的字符串都可改变；</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0);">&nbsp;const</SPAN> 
char *p = greeting;&nbsp;&nbsp;&nbsp; //指针p本身可以改变，如p = 
&amp;Anyother；p所指的字符串不可改变；</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp; &nbsp;char * <SPAN style="color: rgb(255, 0, 0);">cosnt</SPAN> p = 
greeting;&nbsp;&nbsp;&nbsp; //指针p不可改变，所指对象可改变；</SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;<SPAN style="color: rgb(255, 0, 0);">const</SPAN> 
char *<SPAN style="color: rgb(255, 0, 0);"> const </SPAN>p = 
greeting;&nbsp;&nbsp;&nbsp; //指针p及所致对象都不可改变；</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN style="color: rgb(255, 0, 0);">说明：</SPAN><BR></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">如果关键字const出现在星号左边，表示被指物事常量。const char 
  *p和char const *p两种写法意义一样，都说明所致对象为常量；</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">如果关键字const出现在星号右边，表示指针自身是常量。 
  </SPAN>&nbsp;&nbsp; </LI></UL>
<P>&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">STL例子：<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;<SPAN style="color: rgb(0, 0, 0);"><SPAN style="color: rgb(255, 0, 0);"> 
const</SPAN> std::vector&lt;int&gt;::interator iter = vec.begin();//作用像<SPAN 
style="color: rgb(255, 0, 0);">T *const</SPAN>, ++iter 错误：iter是const</SPAN><BR 
style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 
&nbsp;std::vector&lt;int&gt;::<SPAN 
style="color: rgb(255, 0, 0);">const_iterator</SPAN> cIter = 
vec.begin();//作用像<SPAN style="color: rgb(255, 0, 0);">const T*</SPAN>，*cIter = 
10 错误：*cIter是const</SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">以下几点注意：</SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而不至于放弃安全性和高效性。</SPAN></LI>
</UL>
<DIV>&nbsp;&nbsp; &nbsp;例：<SPAN style="font-size: medium;"><SPAN style="color: rgb(255, 0, 0);">const</SPAN> 
Rational operator* （const Rational &amp;lhs, cosnt Rational 
&amp;rhs）;</SPAN><BR>
<UL>
  <LI><SPAN 
  style="font-size: medium;">const成员函数使class接口比较容易被理解，它们使“操作const对象”称为可能；</SPAN></LI>
</UL>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><SPAN style="color: rgb(255, 0, 0);">说明：</SPAN>声明为const的成员函数，不可改变non-static成员变量，在成员变量声明之前添加mutable可让其在const成员函数中可被改变。</SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> <SPAN 
style="color: rgb(255, 0, 0);">const_cast</SPAN>&lt;char &amp;&gt;(<SPAN style="color: rgb(255, 0, 0);">static_cast</SPAN>&lt;const 
TextBlock &amp;&gt;(*this))[position];</SPAN><BR>&nbsp;&nbsp;&nbsp; //<SPAN 
style="font-size: medium;"><SPAN style="color: rgb(255, 0, 0);">static_cast 
<SPAN style="color: rgb(0, 0, 0);">将</SPAN></SPAN></SPAN><SPAN style="font-size: medium;"><SPAN 
style="color: rgb(255, 0, 0);">TextBlock &amp;</SPAN>转为</SPAN><SPAN style="color: rgb(255, 0, 0); font-size: medium;">const 
TextBlock &amp;</SPAN>；<BR>&nbsp;&nbsp;&nbsp; //<SPAN 
style="font-size: medium;"><SPAN style="color: rgb(255, 0, 0);">const_cast<SPAN 
style="color: rgb(0, 0, 0);">将返回值去掉<SPAN 
style="color: rgb(255, 0, 0);">const</SPAN>约束；</SPAN></SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<STRONG><SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">请记住：</SPAN></STRONG><BR>
<UL>
  <LI style="background-color: rgb(255, 255, 255);"><SPAN style="font-size: medium;">将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体；</SPAN> 
  </LI>
  <LI style="background-color: rgb(255, 255, 255);"><SPAN style="font-size: medium;">编译器强制实施bitwise 
  constness，但你编写程序时应该使用“概念上的车辆”（conceptual constness）；</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium; background-color: rgb(255, 255, 255);">当cosnt和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。</SPAN></LI>
</UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款04：确定对象被使用前已先被初始化</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">永远在使用对象之前先将它初始化。对于无任何成员的内置类型，你必须手工完成此事。至于内置类型以外的任何其它东西，初始化责任落在构造函数身上，确保每一个构造函数都将对象的每一个成员初始化。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">赋值和初始化：</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">C++规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。所以应将成员变量的初始化置于构造函数的初始化列表中。</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">ABEntry::ABEntry(const std::string&amp; name, 
const std::string&amp; address,<A id="ch01index145" 
name="ch01index145"></A><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; const 
std::list&lt;PhoneNumber&gt;&amp; phones)<BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp;&nbsp; &nbsp;{ </SPAN><SPAN class="docEmphStrong"><BR><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;theName = name;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; //这些都是赋值，而非初始化</SPAN></SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
class="docEmphStrong"><SPAN style="color: rgb(0, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;theAddress = address;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; //这些成员变量在进入函数体之前已调用<SPAN style="color: rgb(255, 0, 0);">默认构造函数</SPAN>，接着又调用<SPAN 
style="color: rgb(255, 0, 0);">赋值函数</SPAN>，</SPAN></SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
class="docEmphStrong"><SPAN style="color: rgb(0, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;thePhones = phones;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //即要经过<SPAN style="color: rgb(255, 0, 0);">两次的函数调用</SPAN>。 
&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;numTimesConsulted = 
0;</SPAN></SPAN><BR style="color: rgb(0, 0, 0);"><SPAN style="color: rgb(0, 0, 0);">&nbsp;&nbsp; 
&nbsp;} </SPAN></SPAN><BR style="color: rgb(255, 0, 0);"><BR>&nbsp;&nbsp; 
&nbsp;<SPAN style="font-size: medium;">ABEntry::ABEntry(const std::string&amp; 
name, const std::string&amp; address,<A id="ch01index148" 
name="ch01index148"></A><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;const 
std::list&lt;PhoneNumber&gt;&amp; phones) <SPAN 
class="docEmphStrong"><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(0, 0, 0);">&nbsp;: 
theName(name),&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //这些才是初始化</SPAN></SPAN> <SPAN class="docEmphStrong"><BR><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;theAddress(address),&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; //这些成员变量只用相应的值进行<SPAN 
style="color: rgb(255, 0, 0);">拷贝构造函数</SPAN>，所以通常<SPAN style="color: rgb(255, 0, 0);">效率更高</SPAN>。</SPAN></SPAN><BR 
style="color: rgb(0, 0, 0);"><SPAN class="docEmphStrong"><SPAN style="color: rgb(0, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;thePhones(phones),<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;numTimesConsulted(0)</SPAN></SPAN><BR style="color: rgb(0, 0, 0);"><SPAN 
style="color: rgb(0, 0, 0);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{&nbsp;&nbsp; 
&nbsp;} </SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">所以，对于非内置类型变量的初始化应在初始化列表中完成，以提高效率。而对于内置类型对象，如<SPAN 
class="docEmphStrong"><SPAN 
style="color: rgb(0, 0, 0);">numTimesConsulted（int），其初始化和赋值的成本相同，但为了一致性最好也通过成员初始化表来初始化。如果成员变量时const或reference，它们就一定需要初值，不能被赋值。<BR>&nbsp;&nbsp; 
&nbsp;&nbsp; 
C++有着十分固定的“成员初始化次序”。基类总是在派生类之前被初始化，而类的成员变量总是以其说明次序被初始化。所以：<STRONG><SPAN style="color: rgb(255, 0, 0);">当在成员初始化列表中列各成员时，最好总是以其声明次序为次序。</SPAN></STRONG><BR></SPAN></SPAN></SPAN>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI style="background-color: rgb(255, 255, 255);"><SPAN style="font-size: medium;">为内置对象进行手工初始化，因为C++不保证初始化它们；</SPAN> 
  </LI>
  <LI style="background-color: rgb(255, 255, 255);"><SPAN style="font-size: medium;">构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。初始化列表列出的成员变量，其排列次序应该和它们在类中的声明次序相同；</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium; background-color: rgb(255, 255, 255);">为免除“跨编译单元之初始化次序”问题，请以local 
  static对象替换non-local static对象。</SPAN><SPAN style="background-color: rgb(255, 255, 255);"> 
  &nbsp;</SPAN>&nbsp; </LI></UL>
<HR SIZE="2">
<SPAN 
style="color: rgb(0, 0, 255);"><STRONG>二.构造/析构/赋值运算</STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">几乎你写的每个类都会有一或多个构造函数、一个析构函数、一个拷贝赋值操作符。如果这些函数犯错，会导致深远且令人不愉快的后果，遍及整个类。所以确保它们行为正确时生死攸关的大事。</SPAN><BR></SPAN>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款05：了解C++默默编写并调用哪些函数</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="color: rgb(0, 0, 0);"><SPAN 
style="font-size: medium;">如果你自己美声明，编译器就会为类声明（编译器版本的）<SPAN style="color: rgb(255, 0, 0);">一个拷贝构造函数</SPAN>，<SPAN 
style="color: rgb(255, 0, 0);">一个拷贝赋值操作符</SPAN>和<SPAN style="color: rgb(255, 0, 0);">一个析构函数</SPAN>。此外如果你没有声明任何构造函数，编译器也会成为你声明<SPAN 
style="color: rgb(255, 0, 0);">一个默认构造函数</SPAN>。所有这些函数都是<SPAN style="color: rgb(255, 0, 0);">public</SPAN>且<SPAN 
style="color: rgb(255, 0, 0);">inline</SPAN>。<BR>&nbsp;&nbsp; &nbsp; 
惟有当这些函数被需要（被调用），它们才会被编译器创建出来。即<SPAN 
style="color: rgb(255, 0, 0);">有需求，编译器才会创建它们</SPAN>。<BR>&nbsp;&nbsp; &nbsp; 
默认构造函数和析构函数主要是给编译器一个地方用来放置“藏身幕后”的代码，像是调用基类和非静态成员变量的构造函数和析构函数(<SPAN style="color: rgb(255, 0, 0);">要不然它们该在哪里被调用呢？？</SPAN>)。<BR>&nbsp;&nbsp; 
&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">注意：</SPAN>编译器产生的析构函数是个non-virtual，除非这个类的基类自身声明有virtual析构函数。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
至于拷贝构造函数和拷贝赋值操作符，编译器创建的版本只是单纯地将来源对象的每一个非静态成员变量拷贝到目标对象。<BR>&nbsp;&nbsp; &nbsp; 
如一个类声明了一个构造函数（无论有没参数），编译器就不再为它创建默认构造函数。 <BR>&nbsp;&nbsp; &nbsp; 
编译器生成的拷贝赋值操作符：对于成员变量中有指针，引用，常量类型，我们都应考虑建立自己“合适”的拷贝赋值操作符。因为指向同块内存的<SPAN style="color: rgb(255, 0, 0);">指针</SPAN>是个潜在危险，<SPAN 
style="color: rgb(255, 0, 0);">引用</SPAN>不可改变，<SPAN style="color: rgb(255, 0, 0);">常量</SPAN>不可改变。<BR>&nbsp;&nbsp; 
&nbsp;<STRONG style="color: rgb(255, 0, 0);"> 请记住：</STRONG><BR></SPAN></SPAN>
<UL>
  <LI><SPAN style="color: rgb(0, 0, 0);"><SPAN 
  style="font-size: medium;">编译器可以暗自为类创建默认构造函数、拷贝构造函数、拷贝赋值操作符，以及析构函数。&nbsp;</SPAN></SPAN>&nbsp;&nbsp; 
  </LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">通常如果你不希望类支持某一特定技能，只要不说明对应函数就是了。但这个策略对拷贝构造函数和拷贝赋值操作符却不起作用。因为编译器会“自作多情”的声明它们，并在需要的时候调用它们。<BR>&nbsp;&nbsp; 
&nbsp; 由于编译器产生的函数都是public类型，因此可以将拷贝构造函数或拷贝赋值操作符声明为private。通过这个小“伎俩”可以阻止人们<SPAN 
style="color: rgb(255, 0, 0);">在外部</SPAN>调用它，但是类中的成员函数和友元函数还是可以调用private函数。解决方法可能是在一个专门为了阻止拷贝动作而设计的基类。（Boost提供的那个类名为noncopyable）。<BR>&nbsp;&nbsp; 
&nbsp; <STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予实现。使用像noncopyable这样的基类也是一种做法。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款07：为多态基类声明virtual析构函数</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">当基类的指针指向派生类的对象的时候，当我们使用完，对其调用delete的时候，其结果将是未有定义——基类成分通常会被销毁，而派生类的充分可能还留在堆里。这可是形成资源泄漏、败坏之数据结构、在调试器上消费许多时间。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">消除以上问题的做法很简单：给基类一个virtual析构函数。此后删除派生类对象就会如你想要的那般。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
任何类只要带有virtual函数都几乎确定应该也有一个virtual析构函数。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
如果一个类不含virtual函数，通常表示它并不意图被用做一个基类，当类不企图被当做基类的时候，令其析构函数为virtual往往是个馊主意。因为实现virtual函数，需要额外的开销（<SPAN 
style="color: rgb(255, 0, 0);">指向虚函数表的指针vptr</SPAN>）。<BR></SPAN></DIV>
<DIV><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; 
STL容器都不带virtual析构函数，所以最好别派生它们。<BR></SPAN></DIV>
<DIV><SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; <STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">带有多态性质的基类应该声明一个virtual析构函数。如果一个类带有任何virtual函数，它就应该拥有一个virtual析构函数。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">一个类的设计目的不是作为基类使用，或不是为了具备多态性，就不该声明virtual析构函数。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款08：别让异常逃离析构函数</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">C++并不禁止析构函数吐出异常，但它不鼓励你这样做。C++不喜欢析构函数吐出异常。<BR>&nbsp;&nbsp; 
&nbsp; 如果可能导致异常：<BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">如果抛出异常，就结束程序。（强迫结束程序是个合理选项，毕竟它可以阻止异常从析构函数传播出去。）</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">捕获异常，但什么也不做。&nbsp; &nbsp; </SPAN></LI></UL>
<SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; 
如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<STRONG><SPAN style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么类应该提供一个普通函数（而非在析构函数中）执行该操作。&nbsp;&nbsp;</SPAN>&nbsp; 
  </LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款09：决不让构造和析构过程中调用virtual函数</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">你不该在构造函数和析构函数中调用virtual函数，因为这样的调用不会带来你预想的结果。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">因为：基类的构造函数的执行要早于派生类的构造函数，当基类的构造函数执行时，派生类的成员变量尚未初始化。派生类的成员变量没初始化，即为指向虚函数表的指针vptr没被初始化又怎么去调用派生类的virtual函数呢？析构函数也相同，派生类先于基类被析构，又如何去找派生类相应的虚函数？</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">唯一好的做法是：确定你的构造函数和析构函数都没有调用虚函数，而它们调用的所有函数也不应该调用虚函数。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">解决的方法可能是：既然你无法使用虚函数从基类向下调用，那么我们可以使派生类将必要的构造信息向上传递至基类构造函数。即在派生类的构造函数的成员初始化列表中显示调用相应基类构造函数，并传入所需传递信息。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">在构造和析构函数期间不要调用虚函数，因为这类调用从不下降至派生类。&nbsp;</SPAN>&nbsp;&nbsp; 
  </LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN style="color: rgb(204, 0, 0);">条款10：令operator= 
返回一个reference to *this</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">对于赋值操作符，我们常常要达到这种类似效果，即连续赋值：<BR></SPAN>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">&nbsp;&nbsp;int x, y, 
z;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = y = z = 15;<BR>&nbsp;&nbsp; 
&nbsp;&nbsp; 为了实现“连锁赋值”，赋值操作符必须返回一个“引用”指向操作符的左侧实参。<BR>&nbsp;&nbsp; &nbsp;&nbsp; 
即：<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">Widget &amp;</SPAN> operator = (<SPAN style="color: rgb(255, 0, 0);">const 
Widget &amp;rhs</SPAN>)<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;{<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; 
...<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return<SPAN 
style="color: rgb(255, 0, 0);"> *this</SPAN>;<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;}<BR>&nbsp;&nbsp; &nbsp;&nbsp; 
所有内置类型和标准程序库提供的类型如string，vector，complex或即将提供的类型共同遵守。<BR>&nbsp;&nbsp; 
&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR></SPAN>
<UL>
  <LI><SPAN style="font-size: medium;">令赋值操作符返回一个reference to *this。 &nbsp; 
  &nbsp;&nbsp; </SPAN></LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN style="color: rgb(204, 0, 0);">条款11：在operator 
=中处理“自我赋值”</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">先举几个自我赋值的例子：<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
例：Widget w；<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; w = 
w；<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; a[i] = a[j]; //i == j 
or i != j<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; *px = *py;// 
px,py指向同个地址；<BR>&nbsp;&nbsp;&nbsp;&nbsp; 以上情况都是对<SPAN style="color: rgb(255, 0, 0);">“值”</SPAN>的赋值，但我们涉及对<SPAN 
style="color: rgb(255, 0, 0);">“指针”</SPAN>和<SPAN 
style="color: rgb(255, 0, 0);">“引用”</SPAN>进行赋值操作的时候，才是我们真正要考虑的问题了。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
看下面的例子：<BR></SPAN></DIV>
<DIV><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; Widget&amp; 
Widget::operator=(const Widget&amp; rhs) <BR><A id="ch02index185" name="ch02index185"></A>&nbsp;&nbsp; 
&nbsp; { &nbsp;&nbsp; &nbsp;<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; delete 
pb;&nbsp;&nbsp;&nbsp;<SPAN style="color: rgb(255, 0, 0);"> &nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//这里对pb指向内存对象进行delete，试想 *this == 
rhs？情况会如何</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pb = new 
Bitmap(*rhs.pb); &nbsp;&nbsp;&nbsp;<SPAN style="color: rgb(255, 0, 0);"> 
//如果*this == rhs，那么这里还能new吗？“大事不妙”。</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp; return *this; <BR>&nbsp;&nbsp; &nbsp;&nbsp; }<BR>&nbsp;&nbsp; &nbsp; 
也许以下代码能解决以上问题：<BR>&nbsp;&nbsp; &nbsp; Widget&amp; Widget::operator=(const 
Widget&amp; rhs)<A id="ch02index187" name="ch02index187"></A><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;{ <BR><SPAN class="docEmphStrong">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp; <SPAN style="color: rgb(255, 0, 0);">if (this == &amp;rhs) </SPAN><BR 
style="color: rgb(255, 0, 0);"><SPAN style="color: rgb(255, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp; return *this;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; //解决了自我赋值的问题。<BR><BR></SPAN></SPAN>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp; delete pb; <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 
pb = new Bitmap(*rhs.pb); <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; return 
*this; <BR>&nbsp;&nbsp; &nbsp; } </SPAN></DIV>
<DIV><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0);">“许多时候一群精心安排的语句就可以导出异常安全（以及自我赋值安全）的代码。”<SPAN 
style="color: rgb(0, 0, 0);">，以上代码同样存在异常安全问题。</SPAN></SPAN><BR></SPAN>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">Widget&amp; Widget::operator=(const Widget&amp; 
rhs)<A id="ch02index188" name="ch02index188"></A><BR>&nbsp;&nbsp; &nbsp; { <SPAN 
class="docEmphStrong"><BR>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;<SPAN style="color: rgb(255, 0, 0);">Bitmap 
*pOrig = pb;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp; //记住原先的pb</SPAN></SPAN><BR style="color: rgb(255, 0, 0);"><SPAN class="docEmphStrong"><SPAN 
style="color: rgb(255, 0, 0);">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; pb = new 
Bitmap(*rhs.pb);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //令pb指向*pb的一个复本<BR style="color: rgb(255, 0, 0);"></SPAN></SPAN><SPAN 
class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp; delete pOrig;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; //删除原先的pb</SPAN></SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp; return *this;&nbsp;<SPAN style="color: rgb(255, 0, 0);"> 
//这样既解决了自我赋值，又解决了异常安全问题。自我赋值，将pb所指对象换了个存储地址。</SPAN><BR>&nbsp;&nbsp; &nbsp; } 
</SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN style="font-size: medium;">确保当对象自我赋值时operator 
  =有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;">确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。&nbsp;&nbsp;</SPAN>&nbsp; 
  </LI></UL></DIV>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款12：复制对象时勿忘其每一个成员</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">还记得条款5中提到编译器在必要时会为我们提供拷贝构造函数和拷贝赋值函数，它们也许工作的不错，但有时候我们需要自己编写自己的拷贝构造函数和拷贝赋值函数。如果这样，我们应确保对“每一个”成员进行拷贝（复制）。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">如果你在类中添加一个成员变量，你必须同时修改相应的<SPAN style="color: rgb(255, 0, 0);">copying函数（所有的构造函数，拷贝构造函数以及拷贝赋值操作符）</SPAN></SPAN>。<BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">在派生类的构造函数，拷贝构造函数和拷贝赋值操作符中应当显示调用基类相对应的函数，否则编译器可能又“自作聪明了”。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
当你编写一个copying函数，请确保：&nbsp;&nbsp;&nbsp; <BR></SPAN></P>
<DIV style="color: rgb(255, 0, 0);"><SPAN 
style="font-size: medium;">&nbsp;&nbsp;&nbsp; （1）复制所有local成员变量；</SPAN><BR></DIV>
<DIV><SPAN style="font-size: medium;"><SPAN 
style="color: rgb(255, 0, 0);">&nbsp;&nbsp;&nbsp; （2）调用所有基类内的适当copying函数。</SPAN> 
&nbsp;&nbsp;</SPAN><BR></DIV>
<DIV>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">但是，我们不该令拷贝赋值操作符调用拷贝构造函数，也不该令拷贝构造函数调用拷贝赋值操作符。想想，一个是拷贝(建立对象)，一个是赋值(对象已经存在)。<BR>&nbsp;&nbsp;&nbsp; 
<STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">Copying函数应该确保复制“对象内的所有成员变量”及“所有基类成员”；</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;">不要尝试以某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中，并由两个copying函数共同调用。&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
<STRONG><SPAN 
style="color: rgb(0, 0, 255);">三.资源管理</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(0, 0, 255); font-size: medium;">所谓资源就是，一旦用了它，将来必须还给系统。C++程序中最常使用的资源就好似动态分配内存（如果你new了，却忘了delete，会导致内存泄露），但内存只是你必须管理的众多资源之一。其它常见的有文件描述符（file 
descriptors）、互斥器（mutex）、图形界面中的字形和画刷。数据库连接以及网络sockets。当你不使用它们时，记得还给系统。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
当你考虑到异常、函数内多重回传路径、程序维护员改动软件却没能充分理解随之而来的冲击，那么资源管理就显得复杂的多。</SPAN><BR>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(204, 0, 0);"><STRONG>条款13：以对象管理资源</STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="color: rgb(255, 0, 0);">例：</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
</SPAN><SPAN style="font-size: medium;">void f()<A id="ch03index07" name="ch03index07"></A><BR>&nbsp;&nbsp; 
&nbsp; { <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; Investment *pInv = 
createInvestment(); <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; ... &nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">//这里存在诸多“不定因素”，可能造成delete 
pInv；得不到执行，这可能就存在潜在的内存泄露。</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 
delete pInv;<BR>&nbsp;&nbsp; &nbsp; } </SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">解决方法：把资源放进对象内，我们便可依赖C++的“析构函数自动调用机制”确保资源被释放。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">许多资源被动态分配于堆内而后被用于单一区块或函数内。它们应该在控制流离开那个区块或函数时被释放。标准程序库提供的<SPAN 
style="color: rgb(255, 0, 0);">auto_ptr</SPAN>正是针对这种形势而设计的特制产品。<SPAN style="color: rgb(255, 0, 0);">auto_ptr</SPAN>是个“类指针对象”，也就是所谓的“智能指针”，其析构函数自动对其所指对象调用delete。</SPAN><BR>&nbsp;&nbsp; 
&nbsp;<SPAN style="font-size: medium;">void f()<A id="ch03index17" name="ch03index17"></A><BR>&nbsp;&nbsp; 
&nbsp; { <BR><SPAN class="docEmphStrong">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; 
std::auto_ptr&lt;Investment&gt;</SPAN> pInv(createInvestment()); 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; ... <BR>&nbsp;&nbsp; &nbsp; } 
</SPAN>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0); font-size: medium;">//函数退出，</SPAN><SPAN 
style="color: rgb(255, 0, 0); font-size: medium;"><SPAN 
class="docEmphStrong">auto_ptr调用析构函数自动调用delete，删除pInv；</SPAN>无需显示调用delete。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">“以对象管理资源”的<SPAN 
style="color: rgb(255, 0, 0);">两个关键想法</SPAN>：<BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;"><STRONG>获得资源后立刻放进管理对象内</STRONG>（如auto_ptr）。每一笔资源都在获得的同时立刻被放进管理对象中。“资源取得时机便是初始化时机”（Resource 
  Acquisition Is Initialization；RAII）。</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;"><STRONG>管理对象运用析构函数确保资源被释放。</STRONG>即一旦对象被销毁，其析构函数被自动调用来释放资源。</SPAN></LI>
</UL>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">由于<SPAN class="docEmphStrong">auto_ptr被销毁时会自动删除它所指之物，所以</SPAN></SPAN><SPAN 
style="font-size: medium;"><SPAN 
class="docEmphStrong">不能让多个auto_ptr同时指向同一对象。</SPAN>所以</SPAN><SPAN style="font-size: medium;"><SPAN 
class="docEmphStrong">auto_ptr若通过copying函数复制它们，它们会变成NULL，而复制所得的指针将取得资源的唯一拥有权！</SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">看下面例子：</SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">std::<SPAN 
style="color: rgb(255, 0, 0);">auto_ptr</SPAN>&lt;Investment&gt; 
pInv1(createInvestment()); //pInv1指向</SPAN><SPAN 
style="font-size: medium;">createInvestment()返回物；</SPAN><BR><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp; std::<SPAN 
style="color: rgb(255, 0, 0);">auto_ptr</SPAN>&lt;Investment&gt; pInv2(pInv1); 
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">//现在pInv2指向对象，而pInv1被设为NULL;</SPAN><BR>&nbsp;&nbsp; 
&nbsp; pInv1 = pInv2;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">//现在pInv1指向对象，而pIn2被设为NULL;</SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> 受auto_ptr管理的资源必须绝对没有一个以上的</SPAN><SPAN style="font-size: medium;">auto_ptr同时指向它</SPAN>。<SPAN 
style="font-size: medium;">即“<SPAN 
style="color: rgb(255, 0, 0);">有你没我，有我没你</SPAN>”。</SPAN><BR>&nbsp;&nbsp; 
&nbsp;<SPAN 
style="font-size: medium;">auto_ptr的替代方案是“引用计数型智能指针”（reference-counting smart 
pointer；SCSP）、它可以持续跟踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。</SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> TR1的tr1::shared_ptr就是一个"引用计数型智能指针"。<BR>&nbsp;&nbsp; 
&nbsp; void f()<A id="ch03index27" name="ch03index27"></A><BR>&nbsp;&nbsp; 
&nbsp; { <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; ... <SPAN class="docEmphStrong"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="color: rgb(255, 0, 0);"> 
std::tr1::shared_ptr</SPAN></SPAN>&lt;Investment&gt;&nbsp; 
pInv1(createInvestment()); </SPAN><SPAN 
style="font-size: medium;">//pInv1指向</SPAN><SPAN 
style="font-size: medium;">createInvestment()返回物；</SPAN><BR><SPAN style="font-size: medium;"><SPAN 
class="docEmphStrong">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0);">std::tr1::shared_ptr</SPAN></SPAN>&lt;Investment&gt;&nbsp; 
pInv2(pInv1); &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">//</SPAN></SPAN><SPAN style="color: rgb(255, 0, 0); font-size: medium;">pInv1，</SPAN><SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">pInv2指向同一个对象</SPAN><SPAN 
style="font-size: medium;"><SPAN 
style="color: rgb(255, 0, 0);">；</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp; pInv1 = pInv2; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; </SPAN><SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">//同上，无变化</SPAN><SPAN style="font-size: medium;"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp; ... <BR>&nbsp;&nbsp; &nbsp; } </SPAN>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">//函数退出，pInv1，</SPAN><SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">pInv2被销毁，它们所指的对象也竟被自动释放。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">auto_ptr和tr1::shared_ptr都在其析构函数内做delete而不是delete[]，也就意味着在动态分配而得的数组身上使用auto_ptr或tr1::shared_ptr是个潜在危险，资源得不到释放。也许boost::scoped_array和boost::shared_array能提供帮助。还有，vector和string几乎总是可以取代动态分配而得的数组。</SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> <STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">为防止资源泄漏，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">两个常被使用的RAII类分别是auto_ptr和tr1::shared_ptr。后者通常是较佳选择，因为其拷贝行为比较直观。若选择auto_ptr，复制动作会使他（被复制物）指向NULL。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款14：在资源管理类中小心拷贝行为</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">我们在条款13中讨论的资源表现在堆上申请的资源，而有些资源并不适合被auto_ptr和tr1::shared_ptr所管理。可能我们需要建立自己的资源管理类。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><SPAN 
style="color: rgb(255, 0, 0);">例：</SPAN><BR>&nbsp;&nbsp; &nbsp; void lock(Mutex 
*pm); &nbsp;&nbsp;&nbsp; //锁定pm所指的互斥量<BR>&nbsp;&nbsp; &nbsp; unlock(Mutex *pm); 
&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //将pm解除锁定<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
我们建立的资源管理类可能会是这样：<BR>&nbsp;&nbsp; &nbsp; class Lock <BR>&nbsp;&nbsp; &nbsp;{<A 
id="ch03index52" name="ch03index52"></A><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;public: <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;explicit Lock(Mutex 
*pm)<A id="ch03index53" name="ch03index53"></A><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;: mutexPtr(pm) <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;{<BR>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0);">&nbsp;lock(mutexPtr); 
</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} <BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;~Lock() <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{ 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0);">unlock(mutexPtr); 
</SPAN><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} <BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;private: <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;Mutex *mutexPtr; <BR>&nbsp;&nbsp; &nbsp;}; </SPAN><BR><SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp; 
但是，如果Lock对象被复制，会发生什么事？？？<BR>&nbsp;&nbsp;&nbsp; 
“当一个RAII对象被复制，会发生什么事？”大多数时候你会选择一下两种可能：<BR></SPAN>
<UL>
  <LI><STRONG><SPAN style="font-size: medium;">禁止复制。</SPAN></STRONG><SPAN style="font-size: medium;">如果复制动作对RAII类并不合理，你便应该禁止之。禁止类的copying函数参见条款6。</SPAN> 
  </LI>
  <LI><STRONG><SPAN 
  style="font-size: medium;">对底层资源使用”引用计数法“。</SPAN></STRONG><SPAN style="font-size: medium;">有时候我们又希望保有资源，直到它的最后一个使用者被销毁。这种情况下复制RAII对象时，应该将资源的”被引用计数“递增。</SPAN><SPAN 
  style="font-size: medium;">tr1::shared_ptr便是如此。</SPAN><STRONG><SPAN style="font-size: medium;"><BR></SPAN></STRONG></LI>
</UL><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; 
通常只要内含一个tr1::shared_ptr成员变量，RAII类便可实现”引用计数“行为。<BR>&nbsp;&nbsp; &nbsp; class Lock 
<BR>&nbsp;&nbsp; &nbsp;{<A id="ch03index60" 
name="ch03index60"></A><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public: 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;explicit Lock(Mutex 
*pm) <BR><A id="ch03index61" name="ch03index61"></A>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;: mutexPtr(pm<SPAN class="docEmphStrong">, 
<SPAN style="color: rgb(255, 0, 0);">unlock</SPAN></SPAN>)&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; 
//由于tr1::shared_ptr缺省行为是”当引用计数为0时删除其所指物“，幸运的是&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp; //我们可以指定”引用计数“为9时被调用的所谓”删除器“，即第二个参数<SPAN style="color: rgb(255, 0, 0);">unlock</SPAN><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;{ <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;lock(mutexPtr<SPAN class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">.get()</SPAN></SPAN>); 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;} <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;private:<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN 
class="docEmphStrong"><SPAN 
style="color: rgb(255, 0, 0);">std::tr1::shared_ptr&lt;Mutex&gt;</SPAN></SPAN> 
mutexPtr; <BR>&nbsp;&nbsp; &nbsp; }; </SPAN><BR><SPAN 
style="font-size: medium;">&nbsp;&nbsp; &nbsp; 
本例中，并没说明析构函数，因为没有必要。编译器为我们生成的析构函数会自动调用其non-static成员变量（</SPAN><SPAN style="font-size: medium;">mutexPtr</SPAN><SPAN 
style="font-size: medium;">）的析构函数。而</SPAN><SPAN 
style="font-size: medium;">mutexPtr的析构函数会在互斥量”引用计数“为0时自动调用tr1::shared_ptr的删除器（unlock）。<BR>&nbsp;&nbsp;&nbsp; 
Copying函有可能被编译器自动创建出来，因此除非编译器所生成版本做了你想要做的事，否则你得自己编写它们。<BR>&nbsp;&nbsp;&nbsp;<STRONG 
style="color: rgb(255, 0, 0);"> 请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">普遍而常见的RAII类拷贝行为是：抑制拷贝，施行引用计数法。不过其它行为也可能被实现。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
<SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp;<SPAN style="font-size: large;"> 
<STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款15：在资源管理类中提供对原始资源的访问</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">前几个条款提到的资源管理类很棒。它们是你对抗资源泄漏的堡垒。但这个世界并不完美，许多APIs直接指涉资源，这时候我们需要直接访问原始资源。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
这时候需要一个函数可将RAII对象（如tr1::shared_ptr）转换为其所内含之原始资源。有两种做法可以达成目标：<SPAN style="color: rgb(255, 0, 0);">显示转换</SPAN>和<SPAN 
style="color: rgb(255, 0, 0);">隐式转换</SPAN>。</SPAN><BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp; 
tr1::shared_ptr和auto_ptr都提供一个<SPAN 
style="color: rgb(255, 0, 0);">get</SPAN>成员函数，用来执行显示转换，也就是返回智能指针内部的原始指针（的复件）。就像所有智能指针一样，</SPAN><SPAN 
style="font-size: medium;"> tr1::shared_ptr和auto_ptr也重载了指针取值操作符（operator<SPAN 
style="color: rgb(255, 0, 0);">-&gt;</SPAN>和operator<SPAN style="color: rgb(255, 0, 0);">*</SPAN>），它们允许隐式转换至底部原始指针。（即在对智能指针对象实施-&gt;和*操作时，实际被转换为被封装的资源的指针。）</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">class Font <BR>&nbsp;&nbsp; &nbsp;{<A id="ch03index91" 
name="ch03index91"></A><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public: 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;... <SPAN 
class="docEmphStrong"><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;FontHandle get() 
const &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; //</SPAN></SPAN><SPAN style="font-size: medium;"><SPAN 
class="docEmphStrong">FontHandle 是资源；&nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0);">显示转换函数</SPAN></SPAN></SPAN><SPAN 
style="font-size: medium;"><SPAN class="docEmphStrong"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;{ <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;return f; <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;}<BR></SPAN>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <SPAN class="docEmphStrong">operator 
FontHandle() const &nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//<SPAN style="color: rgb(255, 0, 0);">隐式转换&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(0, 0, 0);">这个值得注意，可能引起“非故意之类型转换”</SPAN></SPAN><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;{ <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;return f; <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;}</SPAN></SPAN> <SPAN style="font-size: medium;"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;... <BR>&nbsp;&nbsp; &nbsp;}; </SPAN><BR><SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp; 
是否该提供一个显示转换函数（例如get成员函数）将RAII类转换为其底部资源，或是应该提供隐式转换，答案主要取决于RAII类被设计执行的特定工作，以及它被使用的情况。<BR>&nbsp;&nbsp;&nbsp; 
显示转换可能是比较受欢迎的路子，但是需要不停的get，get；而隐式转换又可能引起“非故意之类型转换”。<BR>&nbsp;&nbsp;&nbsp; 
<STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">APIs往往要求访问原始资源，所以每一个RAII类应该提供一个“取得其所管理之资源”的方法。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
<SPAN style="font-size: medium;"><SPAN 
style="font-size: large;">&nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(204, 0, 0);"><STRONG>条款16：成对使用new和delete时要采取相同形式</STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(0, 0, 0); font-size: medium;">先看下一下代码：</SPAN><BR></SPAN></SPAN>&nbsp;&nbsp; 
&nbsp; std::string *stringArray = new std::string[100];<BR>&nbsp;&nbsp;&nbsp; 
&nbsp;... <BR>&nbsp;&nbsp; &nbsp; delete stringArray;</SPAN><BR><SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; 
使用了new动态申请了资源，也调用了delete释放了资源。但这代码存在“不明确行为”。</SPAN><SPAN style="font-size: medium;">stringArray对象中的99个不太可能被适当删除，因为它们的析构函数很可能没被调用。<BR>&nbsp;&nbsp; 
&nbsp; 
当我们使用new，有两件事情发生：第一，内存被分配出来；第二，针对此内存会有一个（或更多）构造函数被调用。当你使用delete，也有两件事发生：针对此内存会有一个（或多个）析构函数被调用，然后内存才被释放。<SPAN 
style="color: rgb(255, 0, 0);">delete的最大问题在于</SPAN>：即将被删除的内存之内究竟有多少对象？这个问题的答案决定了有多少个析构函数必须被调用起来。<BR></SPAN><SPAN 
style="font-size: medium;">&nbsp;&nbsp; &nbsp; 
解决以上问题事实上很简单：如果你调用new时使用[]，你必须在对应调用delete时也使用[]。如果你调用new时没有使用[]，那么也不该在对应调用delete时使用[]。<BR>&nbsp;&nbsp; 
&nbsp; 最好尽量不要对数组形式作typedefs动作。因为这样容易引起delete操作的“疑惑”（需不需要[]呢？？？）。<BR>&nbsp;&nbsp; 
&nbsp; <STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 
  &nbsp; &nbsp; </SPAN></LI></UL>
<HR SIZE="2">
<SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp; <STRONG><SPAN style="color: rgb(204, 0, 0); font-size: large;">条款17：以独立语句将newed对象置入智能指针</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
为了避免资源泄漏的危险，最好在单独语句内以智能指针存储newed所得对象。<BR>&nbsp;&nbsp;&nbsp; 
即：<BR></SPAN>&nbsp;&nbsp;&nbsp;<SPAN style="font-size: medium;">int 
priority();<A id="ch03index132" name="ch03index132"></A><BR>&nbsp;&nbsp; 
&nbsp;void processWidget(<SPAN 
style="color: rgb(255, 0, 0);">std::tr1::shared_ptr&lt;Widget&gt;</SPAN> pw, int 
priority);<A id="ch03index133" name="ch03index133"></A></SPAN><BR><BR><SPAN 
style="font-size: medium;">&nbsp;&nbsp; &nbsp;<SPAN 
class="docEmphStrong">std::tr1::shared_ptr&lt;Widget&gt; pw(new 
Widget);&nbsp;&nbsp;&nbsp; //即在传入函数之前对智能指针初始化，而不是在传入参数中&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;//对其初始化，因为那样可能引起操作序列的问题。</SPAN><BR>&nbsp; &nbsp; processWidget(<SPAN 
class="docEmphStrong">pw</SPAN>, priority()); </SPAN><SPAN style="font-size: medium;"><BR>&nbsp;<STRONG 
style="color: rgb(255, 0, 0);">&nbsp;&nbsp; </STRONG><STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN>
<UL>
  <LI><SPAN 
  style="font-size: medium;">以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常抛出，有可能导致难以察觉的资源泄漏。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">
<SPAN style="font-size: medium;"><STRONG style="color: rgb(0, 0, 255);"><SPAN 
style="font-size: large;">四.设计与声明</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(0, 0, 255);">所谓软件设计，是“令软件做出你希望它做的事情”的步骤和做法，通常以颇为一般性的构想开始，最终变成十足的细节，以允许特殊接口的开发。</SPAN><BR></SPAN>
<HR SIZE="2">
<SPAN style="font-size: medium;">&nbsp;&nbsp;&nbsp;&nbsp; <STRONG><SPAN style="color: rgb(204, 0, 0); font-size: large;">条款18：让接口容易被正确使用，不易被误用</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
理想上，如果客户企图使用某个接口而却没有获得他所预期的行为，这个代码不该通过编译；如果代码通过了编译，它的作为就该是客户所想要的。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
欲开发一个“容易被正确使用，不容易被误用”的接口，首先必须考虑客户可能做出什么样的错误。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
许多客户端错误可以因为导入新类型而获得预防。在防范“不值得拥有的代码”上，类型系统是你的主要同盟国。<BR>&nbsp;&nbsp; &nbsp;<SPAN 
class="docEmphStrong"> struct Day</SPAN><BR>&nbsp;&nbsp; &nbsp; { 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN 
style="color: rgb(255, 0, 0);">explicit </SPAN>Day(int d)&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; //</SPAN><SPAN style="font-size: medium;"><SPAN style="color: rgb(255, 0, 0);">explicit 
避免隐式的转换。</SPAN></SPAN><SPAN style="font-size: medium;"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;:val(d) {}<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;int 
val; <BR>&nbsp;&nbsp; &nbsp; }; </SPAN><SPAN 
style="font-size: medium;"><BR></SPAN>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">对日期进行类似的类型封装，能有效地避免不恰当的日期赋值。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">“除非有好的理由，否则应该尽量令你的类型（定义的类）的行为与内置类型一致”。</SPAN><BR></DIV>
<P>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">在资源管理方面，也许我们应该“先发制人”，即让函数返回一个资源的指针改为返回一个只能指针。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
例如：<BR>&nbsp;&nbsp; &nbsp; <SPAN 
class="docEmphStrong">std::tr1::shared_ptr&lt;Investment&gt;</SPAN> 
createInvestment();</SPAN><A id="ch04index34" 
name="ch04index34"></A><BR>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">这便实质上强迫客户将返回值存储于一个tr1::shared_ptr内，几乎消除了忘记删除底部Investment对象的可能性。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">tr1::shared_ptr提供的某个构造函数接受两个实参：一个是被管理的指针，另一个是引用次数变成0时被调用的“删除器”。但我们自己制定第二个参数，当然这是安全的。但是留给客户，那也许存在危险。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
std::tr1::shared_ptr&lt;Investment&gt; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;//</SPAN><SPAN 
style="font-size: medium;">tr1::shared_ptr构造函数坚持第一个参数必须是个指针。</SPAN><BR><SPAN 
style="font-size: medium;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;pInv(<SPAN class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">static_cast</SPAN>&lt;Investment*&gt;(</SPAN>0<SPAN 
class="docEmphStrong">)</SPAN>, getRidOfInvestment); 
</SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">tr1::shared_ptr有一个特别好的性质是：它会自动使用它的“每个指针专属的删除器”，因而消除另一个潜在的客户错误：所谓的“cross-DLL 
problem”。因为它缺省的删除器是来自“</SPAN><SPAN 
style="font-size: medium;">tr1::shared_ptr诞生所在的那个DLL</SPAN><SPAN style="font-size: medium;">”的delete。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
请记住：<BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">“阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">tr1::shared_ptr支持定制删除器。这可防范DLL问题，可被用来自动解除互斥量等等。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款19：设计class犹如设计type</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">C++就像在其它面向对象编程语言一样，当你定义一个新class，也就定义了一个新type。这意味着你并不只是类的设计者，更是类型的设计者。重载函数和操作符、控制内存的分配和归还、定义对象的初始化和终结......全部在你手上。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">设计优秀的类是一项艰巨的工作，因为涉及好的类型是一项艰巨的工作。好的类型有自然的语法，直观的语义，以及一或多个高效实现品。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">设计一个良好的类，或者称作类型，考虑一下设计规范：</SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">新类型的对象应该如何被创建和销毁？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">对象的初始化和对象的赋值该有什么样的差别？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">新类型的对象如果被passed by 
  value（值传递），意味着什么？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">什么是新类型的“合法值”？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">你的新类型需要配合某个继承图系吗？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">你的新类型需要什么样的转换？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">什么样的操作符和函数对此新类型而言是合理的？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">什么样的标准函数应该驳回？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">谁该取用新类型的成员？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">什么是新类型的“未声明接口”？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">你的新类型有多少一般化？</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">你真的需要一个新类型吗？&nbsp;</SPAN>&nbsp;&nbsp; 
  </LI></UL>
<P>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">Class的设计就是type的设计。在定义一个新的type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款20：宁以pass-by-reference-to-const替代psss-by-value</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">缺省情况下C++以by 
value方式传递对象至函数。除非你另外指定，否则函数参数都是以实际实参的副本为初值，而调用端所获得的亦是返回值的一个副本。这些副本由对象的拷贝构造函数产生。</SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> 所以在以对象为by 
value时，可能会调用相应的构造函数（成员对象的构造、基类对象的构造），然后调用对应的析构函数。所以以by 
value的形式开销还是比较大的。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
如果我们用pass-by-reference-to-const，例如：<BR>&nbsp;&nbsp; &nbsp;</SPAN><SPAN style="font-size: medium;"> 
bool validateStudent(<SPAN class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">const</SPAN></SPAN> 
Student<SPAN class="docEmphStrong"><SPAN 
style="color: rgb(255, 0, 0);">&amp;</SPAN></SPAN><SPAN style="color: rgb(255, 0, 0);"> 
s</SPAN>);<A id="ch04index84" name="ch04index84"></A> &nbsp;&nbsp;&nbsp; 
//const，希望别对传入对象进行不恰当的修改；<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
这种传递方式效率高得多：没有任何构造函数或析构函数被调用，因为没有任何新对象被创建。</SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN 
style="font-size: medium;">以传引用方式传递参数也可以避免<SPAN 
style="color: rgb(255, 0, 0);">对象切割问题</SPAN>：即当一个派生类对象以传值的方式传递并被视为一个基类对象，基类对象的拷贝构造函数会被调用，而“造成此对象的行为像个派生类对象”的那些特化性质全被切割掉了，仅仅留下了基类对象。这一般不是你想要的。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">所以我们一般的做法应该是这样：<SPAN style="color: rgb(255, 0, 0);">内置对象和STL的迭代器和函数对象，我们一般以传值的方式传递，而其它的任何东西都以传引用的方式传递。</SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">尽量以pass-by-reference-to-const替代pass-by-value。前者通常比较高效，并可避免切割问题。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">以上规则并不使用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款21：必须返回对象时，别妄想返回其reference</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">当我们领悟条款20中传值的开销后，总是避免于少用传值，然而在返回对象时，要格外小心了，因为你可能：传递一些引用或指针指向其实已经不存在的对象。这可不是件好事。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">任何时候看到一个reference声明式，你都应该立刻问自己，它的另一个名称是什么？</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">函数创建新对象的途径有二：在栈空间和堆空间<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0);">栈上</SPAN>：即在函数内的局部变量。局部变量在函数返回后就没有存在的意义，若还对它“念念不忘”，将带来灾难性后果。<SPAN 
style="text-decoration: line-through;"><SPAN 
style="color: rgb(255, 0, 0);">所以传引用在栈上不可行</SPAN>。</SPAN><BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0);">堆上</SPAN>：在堆上构造一个对象，并返回。看似可行，也埋下了资源泄漏的危险。谁该对这对象实施delete呢？别把这种对资源的管理寄托完全寄托于用户。<SPAN 
style="color: rgb(255, 0, 0); text-decoration: line-through;">所以传引用在堆上不可行。</SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">可能还有一种想法：把“让返回的引用指向一个被定义于函数内部的<SPAN style="color: rgb(255, 0, 0);">静态对象</SPAN>”。出于我们对多线程安全性的疑虑，以及当线程中两个函数对单份对象的处理也可能带来不可测行为。<SPAN 
style="color: rgb(255, 0, 0); text-decoration: line-through;">所以静态对象也是不可行的。</SPAN></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0); font-size: medium;">一个“必须返回新对象”的函数的正确写法是：就让那个函数返回一个新对象。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">编译器实现者实行最优化，用以改善产出码的效率却不改变其观察的行为。所以我们还是老老实实的返回一个对象吧。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">绝不要返回pointer或reference指向一个local 
  stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local 
  static对象而有可能同时需要多个这样的对象。&nbsp;&nbsp;</SPAN>&nbsp; </LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款22：将成员变量声明为private</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。例如,这可使得成员变量被读或写时轻松通知其它对象、可以验证calss的约束条件以及函数的前提和事后状态、可以在多线程环境中执行同步控制......<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
不封装意味不可改变！成员变量的封装性与“成员变量的内容改变时所坏量的代码数量”成反比。<BR>&nbsp;&nbsp;&nbsp;&nbsp; <STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保护，并提供class作者以充分的实现弹性。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">protected并不比public更具封装性。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款23：宁以non-member、non-friend替换member函数</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">一般我们相当然以为类中的成员函数更具封装性，而实际上并不是那么一回事，因为成员函数不仅可以访问private成员变量，也可以取用private函数、enums、typedefs等等。而非成员非友元函数能实现更大的封装性，因为它只能访问public函数。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">将所有便利函数放在多个头文件内但隶属同一个命名空间，意味客户可以轻松扩展这一组便利函数。需要做的就是添加更多non-member 
non-friend函数到此命名空间内。<BR>&nbsp;&nbsp;&nbsp; <STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">宁可拿non-member 
  non-friend函数替代member函数。这样做可以增加封装性、包裹弹性和机能扩充性。&nbsp;&nbsp;&nbsp; </SPAN></LI>
</UL>
<HR SIZE="2">

<P><SPAN style="color: rgb(204, 0, 0);">&nbsp;&nbsp;&nbsp; 
<STRONG>条款24：若所有参数皆需类型转换，请为此采用non-member函数</STRONG></SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">通常，令类支持隐式类型转换通常是个糟糕的主意。当然这条规则有其例外，最常见的例外是在建立数值类型时。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
例：<BR>&nbsp;&nbsp; &nbsp; const Rational operator*(const Rational&amp; rhs) 
const; <BR>&nbsp;&nbsp;&nbsp;&nbsp; 
如果定义一个有理数类，并实现*操作符为成员函数，如上所示；那么考虑一下调用：<BR>&nbsp;&nbsp; &nbsp; Rational 
oneHalf(1, 2); <BR>&nbsp;&nbsp; &nbsp; result = <SPAN style="color: rgb(255, 0, 0);">oneHalf 
</SPAN>* 2; // 正确，2被隐式转换为Rational（2，1）<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;//编译器眼中应该是这样：const Rational temp(2); result = oneHalf * temp; 
</SPAN><BR><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; result = <SPAN 
style="color: rgb(255, 0, 0);">2</SPAN> * oneHalf; // 
错误，2，可不被认为是Rational对象；因此无法调用operator*</SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">可见，这样并不准确，因为乘法（*）应该满足交换律，不是吗？</SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> 
所以，支持混合式算术运算的可行之道应该是：让operator*成为一个non-member函数，允许编译器在每一个实参上执行隐式类型转换：<BR>&nbsp;&nbsp; 
&nbsp; class Rational <BR>&nbsp;&nbsp; &nbsp;{<A id="ch04index204" name="ch04index204"></A><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;... // contains no operator* <BR>&nbsp;&nbsp; &nbsp;}; 
<SPAN class="docEmphStrong"><BR>&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(255, 0, 0);">const 
Rational operator*(const Rational&amp; lhs,</SPAN></SPAN>&nbsp;<SPAN class="docEmphStrong"><SPAN 
style="color: rgb(255, 0, 0);"> Rational&amp; rhs)</SPAN></SPAN><BR>&nbsp;&nbsp; 
&nbsp;{ <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return 
Rational(lhs.numerator() * rhs.numerator(), <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;lhs.denominator() * 
rhs.denominator()); <BR>&nbsp;&nbsp; &nbsp;} </SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN 
style="font-size: medium;">Rational oneFourth(1, 4); <BR>&nbsp;&nbsp; &nbsp; 
Rational result; <BR>&nbsp;&nbsp; &nbsp; result = <SPAN style="color: rgb(255, 0, 0);">oneFourth 
</SPAN>* 2; <BR>&nbsp;&nbsp; &nbsp; result = <SPAN style="color: rgb(255, 0, 0);">2</SPAN> 
* oneFourth;&nbsp; 
//这下两个都工作的很好，通过隐式转换实现</SPAN><BR>&nbsp;&nbsp;&nbsp;<STRONG><SPAN style="font-size: medium;"> 
成员函数的方面是非成员函数，而不是友元函数。</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="font-size: medium;">可以用类中的public接口实现的函数，最好就是非成员函数，而不是采用友元函数。</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。&nbsp;&nbsp;</SPAN>&nbsp; 
  </LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);"><STRONG>条款25：考虑写出一个不抛异常的swap函数</STRONG><BR>&nbsp;&nbsp;&nbsp; 
......<BR></SPAN>&nbsp;&nbsp;<SPAN style="font-size: medium;">&nbsp; <STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">如果你提供一个member swap，也该提供一个non-member 
  swap用来调用前者。对于class（而非templates），也请特化std::swap。</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;">调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">为“用户定义类型”进行std 
  templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。&nbsp;&nbsp;&nbsp;</SPAN></LI></UL>
<HR SIZE="2">

<P><SPAN style="color: rgb(0, 0, 255);"><STRONG>五.实现&nbsp;</STRONG>&nbsp;&nbsp; 
</SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(0, 0, 255); font-size: medium;">大多数情况下，适当提出拟的类定义以及函数声明，是花费最多心力的两件事。尽管如此，还是有很多东西需要小心：太快定义变量可能造成效率上的拖延；过度使用转型（casts）可能导致代码变慢又难维护，又招来微妙难解的错误；返回对象“内部数据之号码牌（handls）”可能会破坏封装并留给客户虚吊号码牌；为考虑异常带来的冲击则可能导致资源泄漏和数据败坏；过度热心地inlining可能引起代码膨胀；过度耦合则可能导致让人不满意的冗长建置时间。 
&nbsp;</SPAN>&nbsp;</P>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款26：尽可能延后变量定义式的出现时间</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">只要你定义了一个变量而其类型带有一个构造函数或析构函数，那么当程序的控制流到达这个变量定义式时，你便得承受构造成本；当这个变量离开其作用域时，你便得承受析构成本。即使这个变量最终并为被使用，仍需耗费这些成本，所以应该尽量避免这种情形。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">std::string encryptPassword(const 
std::string&amp; password)<A id="ch05index10" 
name="ch05index10"></A><BR>&nbsp;&nbsp; &nbsp;{ <BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;using namespace std; <SPAN 
class="docEmphStrong"><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="color: rgb(255, 0, 0);">string 
encrypted<STRONG style="color: rgb(0, 0, 255);"><SUP><SPAN style="font-size: small;">1</SPAN></SUP></STRONG>;</SPAN></SPAN><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;if (password.length() &lt; MinimumPasswordLength) 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{ <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;throw logic_error("Password is too short"); 
&nbsp;&nbsp;&nbsp; //注意：可能抛出异常<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;}<BR></SPAN><SPAN style="font-size: medium;"><SPAN 
class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;string encrypted<STRONG 
style="color: rgb(0, 0, 255);"><SUP><SPAN 
style="font-size: small;">2</SPAN></SUP></STRONG>;</SPAN></SPAN></SPAN><BR><SPAN 
style="font-size: medium;">&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;... 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;return encrypted; <BR>&nbsp;&nbsp; 
&nbsp; } </SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><SPAN 
style="color: rgb(0, 0, 0);">如上代码，</SPAN><SPAN class="docEmphStrong"><SPAN 
style="color: rgb(255, 0, 0);">encrypted</SPAN></SPAN></SPAN><SPAN style="font-size: medium;">在2处定义是个不错的选择，因为如果抛出异常，那么</SPAN><SPAN 
style="font-size: medium;"><SPAN class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">encrypted<SPAN 
style="color: rgb(0, 0, 0);">的构造和析构可是做了无用功啊！<BR>&nbsp;&nbsp; &nbsp; 
还有一点要注意：“通过默认构造函数构造出一个对象然后对它赋值”比“直接在构造函数时制定初值”效率差。<BR>&nbsp;&nbsp; &nbsp; 
“尽可能延后”的真正意义应该是：<SPAN 
style="color: rgb(0, 0, 255);">你不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初值实参为止。<BR>&nbsp;&nbsp; 
&nbsp; //方法A:定义循环外<BR></SPAN></SPAN></SPAN></SPAN></SPAN>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><SPAN class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">Widget 
w;</SPAN></SPAN><BR>&nbsp;&nbsp; &nbsp; for (int i = 0; i &lt; n; ++i) 
<BR>&nbsp;&nbsp; &nbsp;{ <SPAN class="docEmphStrong"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="color: rgb(255, 0, 0);">w</SPAN> =</SPAN> 
<SPAN class="docEmphasis">some value dependent on i;<BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp; ...</SPAN><BR>&nbsp;&nbsp;&nbsp; }</SPAN> &nbsp;&nbsp; 
&nbsp;<SPAN 
style="font-size: medium;">//1个构造函数+1个析构函数+n个赋值操作；</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(0, 0, 255); font-size: medium;">//方法B：定义循环外</SPAN><BR><SPAN 
style="font-size: medium;">&nbsp;&nbsp; &nbsp; for (int i = 0; i &lt; n; ++i) 
<BR>&nbsp;&nbsp; &nbsp;{<BR><SPAN class="docEmphStrong">&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;<SPAN style="color: rgb(255, 0, 0);">Widget 
w</SPAN>(</SPAN><SPAN class="docEmphasis">some value dependent on i</SPAN><SPAN 
class="docEmphStrong">);</SPAN>&nbsp; <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;...<BR>&nbsp;&nbsp; &nbsp;} </SPAN>&nbsp;&nbsp; &nbsp;<SPAN style="font-size: medium;">//n个构造函数+n个析构函数</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">除非：1.你知道赋值成本比“构造+析构”成本低；2.你正在处理代码中效率高度敏感的部分，否则<SPAN 
style="color: rgb(0, 0, 255);">应该使用方法B</SPAN>。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款27：尽量少做转型动作</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp;<SPAN 
style="font-size: medium;"> 
C++规则的设计目标之一是，保证“类型错误”绝不可能发生。不幸的是，转型（casts）破坏了类型系统。那可能导致任何种类的麻烦，有些容易辨识，有些非常隐晦。<BR></SPAN>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">C风格的转型动作看起来像这样：<BR>&nbsp;&nbsp; &nbsp; 
(T)expression&nbsp;&nbsp;&nbsp; //将expression转型为T<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
函数风格的转型动作看起来像这样：<BR>&nbsp;&nbsp;&nbsp;&nbsp; T(expression)&nbsp;&nbsp; 
&nbsp;//将expression转型为T</SPAN><BR>&nbsp;&nbsp;&nbsp;<SPAN style="font-size: medium;"> 
C++还提供四种新式转型：<BR>&nbsp;&nbsp;&nbsp;&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">const_cast</SPAN>:通常被用来将对象的常量性转除；即去掉const。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0);">dynamic_cast</SPAN>:主要用来执行“安全向下转型”，也就是用来决定某对象是否归属继承体系中的某个类型。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
<SPAN 
style="color: rgb(255, 0, 0);">reinterpret_cast</SPAN>:意图执行低级转型，实际动作可能取决于编译器，这也就表示它不可移植。<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN 
style="color: rgb(255, 0, 0);"> 
static_cast</SPAN>:用来强迫隐式转换，例如将non-const转型为const，int转型为double等等。</SPAN><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG>尽量使用新式转型：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">它们很容易在代码中被辨识出来，因而得以简化“找出类型系统在哪个地点被破坏”的过程。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">各转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。&nbsp;&nbsp;&nbsp;</SPAN></LI>
</UL>
<P>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">宁可使用C++-style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的执掌。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款28：避免返回handls指向对象内部成分</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">struct RectData <BR>&nbsp;&nbsp; &nbsp; { 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Point <SPAN style="color: rgb(255, 0, 0);">ulhc</SPAN>; 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;Point <SPAN style="color: rgb(255, 0, 0);">lrhc</SPAN>; 
<BR>&nbsp;&nbsp; &nbsp; }; </SPAN><BR>&nbsp;&nbsp; &nbsp;<SPAN style="font-size: medium;">class 
Rectangle <BR>&nbsp;&nbsp; &nbsp;{<A id="ch05index90" 
name="ch05index90"></A><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;public: 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;... <SPAN class="docEmphStrong"><BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<SPAN 
style="color: rgb(255, 0, 0);">Point&amp;</SPAN></SPAN> upperLeft() <SPAN style="color: rgb(255, 0, 0);">const 
</SPAN>{ return pData-&gt;ulhc; }</SPAN><SPAN style="font-size: small;"><SUP 
style="color: rgb(0, 0, 255);">1</SUP></SPAN><SPAN 
style="font-size: medium;">//<SPAN 
style="color: rgb(255, 0, 0);">const</SPAN>只对函数内进行保护，函数返回后呢？？</SPAN><SPAN style="font-size: medium;"><A 
id="ch05index91" name="ch05index91"></A><SPAN 
class="docEmphStrong"><BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;<SPAN style="color: rgb(255, 0, 0);">Point&amp;</SPAN></SPAN> lowerRight() 
<SPAN style="color: rgb(255, 0, 0);">const </SPAN>{ return pData-&gt;lrhc; }<SUP 
style="color: rgb(0, 0, 255);"><SPAN style="font-size: small;">2 </SPAN></SUP><A 
id="ch05index92" name="ch05index92"></A>//<SPAN 
style="color: rgb(255, 0, 0);">const</SPAN>只对函数内进行保护，函数返回后呢？？<BR>&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;private: <BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; &nbsp;std::tr1::shared_ptr&lt;RectData&gt; pData; 
<BR>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;... 
<BR>&nbsp;&nbsp; &nbsp;}; </SPAN><BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">1，2两函数都返回引用，指向private内部数据，调用者于是可通过这些引用更改内部数据！这严重破坏了数据的封装性，对私有成员进行直接操作？太不可思意了！</SPAN><BR>&nbsp;&nbsp; 
&nbsp; <SPAN style="font-size: medium;"><SPAN class="docEmphStrong"><SPAN style="color: rgb(255, 0, 0);">const</SPAN></SPAN><SPAN 
style="color: rgb(255, 0, 0);"> Point&amp;</SPAN> upperLeft() const { return 
pData-&gt;ulhc; }<SUP style="color: rgb(0, 0, 255);"><SPAN style="font-size: small;">3</SPAN></SUP><A 
id="ch05index100" name="ch05index100"></A><BR>&nbsp;&nbsp; &nbsp; &nbsp; <SPAN 
class="docEmphStrong"><SPAN 
style="color: rgb(255, 0, 0);">const</SPAN></SPAN><SPAN style="color: rgb(255, 0, 0);"> 
Point&amp; </SPAN>lowerRight() const { return pData-&gt;lrhc; }<A id="ch05index101" 
name="ch05index101"></A></SPAN><SPAN style="font-size: small;"><SUP style="color: rgb(0, 0, 255);">4 
</SUP></SPAN><SPAN style="font-size: medium;">&nbsp;&nbsp; 
&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
或者将1，2改为3，4，这就限制了客户的“涂改权”，只有“读取权”</SPAN>。<BR>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;">但终究“返回一个handle代表对象内部成分”总是危险的。特别是将返回的指针或引用赋值给其它指针或引用，那么久造成了“悬空”</SPAN>。<BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;"><STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">避免返回handles（包括reference、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”（dangling 
  handles）的可能性降至最低。&nbsp;&nbsp;&nbsp; </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款29：为“异常安全”而努力是值得的</SPAN></STRONG><BR><SPAN 
style="font-size: medium;"><STRONG>&nbsp;&nbsp;&nbsp; <SPAN style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">异常安全函数（Exception-safe 
  functions）即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;">“强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。&nbsp;</SPAN>&nbsp;&nbsp; 
  </LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款30：透彻了解inlining的里里外外</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN 
style="font-size: medium;">Inline函数，多棒的点子！它们看起来像函数，动作像函数，比宏好得多，可以调用它们又不需蒙受函数调用所招致的额外开销。你实际获得的比想象的还多，编译器有能力对执行语境相关最优化。然而编写程序就像现实生活一样，没有白吃的午餐。inline函数也不例外，这样做可能增加你的目标码。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
如果inline函数的本体很小，编译器针对“函数本体”所产生的码可能比针对“函数调用”所产出的码更小。果真如此，将函数inlining确实可能导致较小的目标码和较高的指令高速缓存装置击中率。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
记住，inline只是对编译器的一个申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。<SPAN style="color: rgb(255, 0, 0);">隐喻方式</SPAN>是将函数定义于class定义式内,这样的函数通常是成员函数，friend函数也可被定义于class内，如果真是那样，它们也是被隐喻声明为inline。明确声明inline函数的做法则是在其定义式钱加上关键字<SPAN 
style="color: rgb(255, 0, 0);">inline</SPAN>。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
Inline函数通常一定被置于头文件内，因为大多数建置环境在编译过程中进行inlining，而为了将一个“函数调用”替换为“被调用函数的本体”，编译器必须知道那个函数长什么样子。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
Template通常也被置于头文件内，因为它一旦被使用，编译器为了将它具现化，需要知道哦啊它长什么样子。<BR>&nbsp;&nbsp;&nbsp;&nbsp; 
Template的具现化与inlining无关。如果你正在写一个template而你认为所有根据此template具现出来的函数都应该inlined，请将此template声明为inline；但如果你写的template煤油理由要求它所具现的每一个函数都是inlined，就应该避免将这个template声明为inline。<BR>&nbsp;&nbsp; 
&nbsp; <SPAN 
style="color: rgb(255, 0, 0);">一个表面上看似inline的函数是否真实inline，取决于你的建置环境，主要取决于编译器。<BR>&nbsp;&nbsp; 
&nbsp; <SPAN style="color: rgb(0, 0, 0);"><SPAN style="background-color: rgb(207, 226, 243);">有的时候虽然编译器有意愿inlining某个函数，还是可能为该函数生成一个函数本体（函数指针，构造函数，析构函数）。<BR><SPAN 
style="background-color: rgb(255, 255, 255);">&nbsp;&nbsp; &nbsp; 
对程序开发而言，将上述所有考虑牢记在新很是重要，但若从纯粹实用观点出发，有一个事实比其它因素更重要：<SPAN style="color: rgb(255, 0, 0);">大部分调试器面对inline函数都束手无策。<BR>&nbsp;&nbsp; 
&nbsp; <SPAN 
style="color: rgb(0, 0, 0);">这使我们在决定哪些函数该被声明为inline而哪些函数不该时，掌握一个合乎逻辑的策略。一开始先不要将任何函数声明为inline，或至少将inlining施行范围局限在那些“一定成为inline”或“十分平淡无奇”的函数身上。</SPAN><BR></SPAN></SPAN></SPAN></SPAN></SPAN>&nbsp;&nbsp; 
&nbsp; <STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级更容易，也可使潜在的代码膨胀问题最小化，是程序的速度提升机会最大化。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">不要只因为function 
  templates出现在头文件，就将它们声明为inline。&nbsp;&nbsp;&nbsp; </SPAN></LI></UL>
<HR SIZE="2">

<P><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; <STRONG><SPAN style="color: rgb(204, 0, 0); font-size: large;">条款31：将文件间的编译依存关系降至最低</SPAN></STRONG><BR>&nbsp;&nbsp; 
&nbsp; <STRONG><SPAN 
style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle 
  classed和Interface classes。</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">程序库头文件应该以“完全且仅有声明式”（full and 
  declaration-only forms）的形式存在。这种做法不论是否涉及templates都适用。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P><STRONG style="color: rgb(0, 0, 255);"><SPAN 
style="font-size: large;">六.继承与面向对象设计<BR>&nbsp;&nbsp;&nbsp; 
</SPAN></STRONG><SPAN style="color: rgb(0, 0, 255);"><SPAN style="font-size: medium;">如果你了解C++各种特性的意义，你会发现，你对OOP的看法改变了。它不再是一项用来划分语言特性的仪典，而是可以让你通过它说出你对软件系统的想法。一旦你知道该通过它说些什么，移转至C++世界也就不再是可怕的高要求了。</SPAN></SPAN><STRONG 
style="color: rgb(0, 0, 255);"><SPAN 
style="font-size: large;"><BR></SPAN></STRONG></P>
<HR SIZE="2">

<P>&nbsp;&nbsp;&nbsp; <STRONG><SPAN 
style="color: rgb(204, 0, 0);">条款32：确定你的public继承塑模出is-a关系</SPAN></STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="font-size: medium;">以C++进行面向对象编程，最重要的一个规则是：<SPAN style="color: rgb(255, 0, 0);">public 
inheritance（公有继承）意味is-a（是一种）的关系。</SPAN></SPAN><BR><STRONG style="color: rgb(0, 0, 255);">&nbsp;&nbsp;&nbsp; 
</STRONG><SPAN style="font-size: medium;"><SPAN 
style="color: rgb(0, 0, 0);">如果你令class D以public形式继承class 
B，你便是告诉C++编译器（以及你的代码读者）说，每一个类型为D的对象同时也是一个类型为B的对象，反之不成立。你的意思是B比D表现出更一般化得概念，而D比B表现出更特殊化的概念。你主张：“B对象可派上用场的任何地方，D对象一样可以派上用场”，因为每一个D对象都是一种（是一个）B对象。反之如果你需要一个D对象，B对象无法效劳，因为虽然每个D对象都是一个B对象，反之并不成立。<BR>&nbsp;&nbsp; 
&nbsp; 
在C++领域中，任何函数如果期望获得一个类型为基类的实参（而不管是传指针或是引用），都也愿意接受一个派生类对象（而不管是传指针或是引用）。（只对public继承才成立。）<BR>&nbsp;&nbsp; 
&nbsp; <SPAN 
style="background-color: rgb(207, 226, 243);">好的接口可以防止无效的代码通过编译，因此你应该宁可采取“在编译期拒绝”的设计，而不是“运行期才侦测”的设计。</SPAN><BR>&nbsp;&nbsp; 
&nbsp; <STRONG 
style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;"><SPAN 
  style="color: rgb(0, 0, 0);">“public继承”意味is-a。适用于base 
  classes身上的每一件事情一定也使用于derived classes身上，因为每一个derived classes对象也都是一个base 
  classes对象。 &nbsp; &nbsp; </SPAN></SPAN></LI></UL>
<HR SIZE="2">

<P><STRONG style="color: rgb(0, 0, 255);">&nbsp;&nbsp;&nbsp; 
</STRONG><STRONG><SPAN style="color: rgb(204, 0, 0);"><SPAN style="font-size: large;">条款33：避免遮掩继承而来的名称</SPAN></SPAN></STRONG><STRONG 
style="color: rgb(0, 0, 255);"><SPAN 
style="font-size: large;"><BR>&nbsp;&nbsp;&nbsp;</SPAN></STRONG> <SPAN style="color: rgb(0, 0, 0); font-size: medium;">C++的名称遮掩规则所做的唯一事情就是：遮掩名称。至于名称是否是相同或不同的类型，并不重要。即，只要名称相同就覆盖基类相应的成员，不管是类型，参数个数，都无关紧要。<SPAN 
style="color: rgb(255, 0, 0);">派生类的作用域嵌套在基类的作用域内。</SPAN><BR>&nbsp;&nbsp; &nbsp; 
C++的继承关系的遮掩名称也并不管成员函数是纯虚函数，非纯虚函数或非虚函数等。<SPAN 
style="color: rgb(255, 0, 0);">只和名称有关。 <BR>&nbsp;&nbsp; &nbsp; <SPAN style="color: rgb(0, 0, 0);">如果你真的需要用到基类的被名称遮掩的函数，可以使用using声明式，引入基类的成员函数。</SPAN><BR></SPAN></SPAN><STRONG 
style="color: rgb(0, 0, 255);">&nbsp;&nbsp;&nbsp; </STRONG><SPAN style="font-size: medium;"><STRONG><SPAN 
style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR style="color: rgb(0, 0, 0);"></SPAN></P>
<UL>
  <LI><SPAN style="color: rgb(0, 0, 0); font-size: medium;">derived 
  calsses内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 &nbsp;&nbsp;</SPAN> </LI>
  <LI><SPAN style="color: rgb(0, 0, 0);"><SPAN 
  style="font-size: medium;">为了让被遮掩的名称再见天日，可使用using声明式或转交函数（forwarding 
  function）。</SPAN></SPAN></LI></UL>
<HR SIZE="2">

<P><STRONG style="color: rgb(0, 0, 255);">&nbsp;&nbsp;&nbsp; 
</STRONG><STRONG><SPAN style="color: rgb(204, 0, 0);"><SPAN style="font-size: large;">条款34：区分接口继承和实现继承</SPAN></SPAN></STRONG><STRONG 
style="color: rgb(0, 0, 255);"><SPAN 
style="font-size: large;"><BR>&nbsp;&nbsp;&nbsp; </SPAN></STRONG><SPAN style="font-size: large;"><SPAN 
style="font-size: medium;"><SPAN 
style="color: rgb(0, 0, 0);">表面上直截了当的public继承概念，经过更严密的检查之后，发现它由两部分组成：<SPAN 
style="color: rgb(255, 0, 0);">函数接口继承</SPAN>和<SPAN style="color: rgb(255, 0, 0);">函数实现继承</SPAN>。</SPAN></SPAN><BR></SPAN></P>
<UL style="color: rgb(0, 0, 0);" type="square">
  <LI><SPAN style="font-size: medium;">成员函数的接口总是会被继承。</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">声明一个纯虚函数的目的是为了让派生类<SPAN style="color: rgb(255, 0, 0);">只继承函数接口</SPAN>。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">声明一个虚函数的目的是让派生类<SPAN style="color: rgb(255, 0, 0);">继承该函数的接口和缺省实现</SPAN>。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">声明一个非虚函数的目的是为了令派生类<SPAN style="color: rgb(255, 0, 0);">继承函数的接口及一份强制性实现</SPAN>。</SPAN></LI>
</UL>
<P>&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">接口继承和实现继承不同。在public继承之下，derived 
  classes总是继承base class的接口。</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">pure virtual函数只具体制定接口继承。</SPAN> </LI>
  <LI><SPAN style="font-size: medium;">简朴的（非纯）impure 
  virtual函数具体制定接口继承及缺省实现继承。</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;">non-virtual函数具体制定接口继承以及强制性实现继承。</SPAN></LI></UL>
<HR SIZE="2">

<P><STRONG style="color: rgb(0, 0, 255);">&nbsp;&nbsp;&nbsp; </STRONG><SPAN 
style="color: rgb(204, 0, 0);"><SPAN 
style="font-size: large;"><STRONG>条款35：考虑virtual函数以外的其它选择</STRONG><BR></SPAN></SPAN><STRONG 
style="color: rgb(0, 0, 255);">&nbsp;&nbsp;&nbsp; <SPAN style="font-size: medium;"><SPAN 
style="color: rgb(255, 0, 0);">请记住：</SPAN><BR></SPAN></STRONG></P>
<UL style="color: rgb(0, 0, 0);">
  <LI><SPAN 
  style="font-size: medium;">virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template 
  Method设计模式。</SPAN> </LI>
  <LI><SPAN 
  style="font-size: medium;">将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员。</SPAN> 
  </LI>
  <LI><SPAN 
  style="font-size: medium;">tr1::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式（target 
  signature）兼容”的所有可调用物（callable entities）。&nbsp;&nbsp;&nbsp; </SPAN></LI></UL>
<HR SIZE="2">

<P><STRONG style="color: rgb(0, 0, 255);">&nbsp;&nbsp; 
&nbsp;</STRONG><STRONG><SPAN style="font-size: large;"><SPAN style="color: rgb(204, 0, 0);">条款36：绝不重新定义继承而来的non-virtual函数</SPAN></SPAN></STRONG><SPAN 
style="font-size: medium;"><SPAN 
style="font-size: large;"><BR></SPAN>&nbsp;&nbsp; &nbsp; <STRONG><SPAN style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="font-size: medium;">绝对不要重新定义继承而来的non-virtual函数。&nbsp;&nbsp;&nbsp; 
  </SPAN></LI></UL>
<HR SIZE="2">

<P>&nbsp;&nbsp; &nbsp; <SPAN 
style="color: rgb(204, 0, 0); font-size: large;"><STRONG>条款37：绝不重新定义继承而来的缺省参数值</STRONG><BR>&nbsp;&nbsp;&nbsp; 
<SPAN style="color: rgb(0, 0, 0); font-size: medium;">对于</SPAN></SPAN><SPAN 
style="color: rgb(0, 0, 0); font-size: medium;">non-virtual函数</SPAN><SPAN style="color: rgb(0, 0, 0); font-size: medium;">，上一条款说到，“绝不重新定义继承而来的</SPAN><SPAN 
style="color: rgb(0, 0, 0); font-size: medium;">non-virtual函数</SPAN><SPAN style="color: rgb(0, 0, 0); font-size: medium;">”，而对于继承一个带有缺省参数值的virtual函数，也是如此。即绝不重新定义继承而来的缺省参数值。因为：virtual函数系动态绑定（dynamically 
bound），而缺省参数值确实静态绑定（statically 
bound）。意思是你可能会在“调用一个定义于派生类内的虚函数”的同时，却使用基类为它所指定的缺省参数值。<BR>&nbsp;&nbsp; &nbsp; 
<STRONG><SPAN style="color: rgb(255, 0, 0);">请记住：</SPAN></STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN 
  style="color: rgb(0, 0, 0); font-size: medium;">绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。</SPAN></LI>
</UL>
<HR SIZE="2">

<P><SPAN style="font-size: medium;">&nbsp;&nbsp; &nbsp; <STRONG><SPAN style="color: rgb(204, 0, 0); font-size: large;">条款38：通过符合塑模出has-a或“根据某物实现出”</SPAN></STRONG><BR>&nbsp;&nbsp; 
&nbsp; <STRONG style="color: rgb(255, 0, 0);">请记住：</STRONG><BR></SPAN></P>
<UL>
  <LI><SPAN style="font-size: medium;">复合（composition）的意义和public继承完全不同。</SPAN> 
  </LI>
  <LI><SPAN style="font-size: medium;">在应用域（application 
  domain），复合意味has-a（有一个）。在实现域（implementation 
  domain），复合意味is-implemented-in-terms-of（根据某物实现出）。 &nbsp;&nbsp; <BR></SPAN></LI>
</UL>
<P><SPAN 
style="font-size: medium;"><BR><BR><BR><BR><BR><BR><BR><BR><BR></SPAN></P></DIV><!-- Baidu Button BEGIN -->
<DIV style="float: right;" class="bdsharebuttonbox"><A style='background-image: url("http://bdimg.share.baidu.com/static/api/img/share/icons_0_16.png?v=d754dcc0.png") !important;' 
class="bds_more" href="http://blog.csdn.net/shenzi/article/details/5601038#" 
data-cmd="more"></A><A style="background-position: 0px -52px !important;" class="bds_qzone" 
title="分享到QQ空间" href="http://blog.csdn.net/shenzi/article/details/5601038#" 
data-cmd="qzone"></A><A style="background-position: 0px -104px !important;" 
class="bds_tsina" title="分享到新浪微博" href="http://blog.csdn.net/shenzi/article/details/5601038#" 
data-cmd="tsina"></A><A style="background-position: 0px -260px !important;" 
class="bds_tqq" title="分享到腾讯微博" href="http://blog.csdn.net/shenzi/article/details/5601038#" 
data-cmd="tqq"></A><A style="background-position: 0px -208px !important;" class="bds_renren" 
title="分享到人人网" href="http://blog.csdn.net/shenzi/article/details/5601038#" 
data-cmd="renren"></A><A style="background-position: 0px -1612px !important;" 
class="bds_weixin" title="分享到微信" href="http://blog.csdn.net/shenzi/article/details/5601038#" 
data-cmd="weixin"></A></DIV>
<SCRIPT>window._bd_share_config = { "common": { "bdSnsKey": {}, "bdText": "", "bdMini": "1", "bdMiniList": false, "bdPic": "", "bdStyle": "0", "bdSize": "16" }, "share": {} }; with (document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];</SCRIPT>
<!-- Baidu Button END --><!--192.168.100.36-->
<UL class="article_next_prev">
  <LI class="prev_article"><SPAN onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian']);location.href='/shenzi/article/details/5571446';">上一篇</SPAN><A 
  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_shangyipian'])" 
  href="http://blog.csdn.net/shenzi/article/details/5571446">面向对象设计原则及设计模式</A></LI>
  <LI class="next_article"><SPAN onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian']);location.href='/shenzi/article/details/5653720';">下一篇</SPAN><A 
  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_xiayipian'])" 
  href="http://blog.csdn.net/shenzi/article/details/5653720">致加西亚的信 名言佳句 
  </A></LI></UL><!-- Baidu Button BEGIN -->
<SCRIPT id="bdshare_js" type="text/javascript" data="type=tools&amp;uid=1536434"></SCRIPT>

<SCRIPT id="bdshell_js" type="text/javascript"></SCRIPT>

<SCRIPT type="text/javascript">
    document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)
</SCRIPT>
<!-- Baidu Button END --></DIV>
<DL class="blog-associat-tag">
  <DT>主题推荐</DT>
  <DD><A class="blog-tage-red" href="http://www.csdn.net/tag/读书笔记" target="_blank">读书笔记</A><A 
  class="blog-tage-red" href="http://www.csdn.net/tag/c++" 
  target="_blank">c++</A><A class="blog-tage-red" href="http://www.csdn.net/tag/面向对象编程" 
  target="_blank">面向对象编程</A><A class="blog-tage-red" href="http://www.csdn.net/tag/内存泄露" 
  target="_blank">内存泄露</A><A class="blog-tage-red" href="http://www.csdn.net/tag/设计模式" 
  target="_blank">设计模式</A></DD></DL>
<STYLE>
.blog-ass-articl dd {
color: #369;
width: 99%; /*修改行*/
float: left;
overflow: hidden;
font: normal normal 12px/23px "SimSun";
height: 23px;
margin: 0;
padding: 0 0 0 10px;
margin-right: 30px;
background: url(../images/blog-dot-red3.gif) no-repeat 0 10px;
}

</STYLE>

<DL id="res-relatived" class="blog-ass-articl">
  <DT><SPAN>猜你在找</SPAN></DT>
  <DIV style="width: 42%; margin-right: 30px; float: left;" id="res" class="tracking-ad" 
  data-mod="popu_36"></DIV>
  <DIV style="width: 42%; float: left;" id="adCollege">
<SCRIPT type="text/javascript" src="effective_files/job_reco.js"></SCRIPT>

<SCRIPT type="text/javascript">
            csdn.position.showEdu({
                sourceType: "blog",
                searchType: "detail",
                searchKey: "5601038",
                username: "",
                recordcount: "5",
                containerId: "adCollege" //容器DIV的id。 
            });
        </SCRIPT>
  </DIV></DL>
<DIV id="job_blog_reco">
<SCRIPT type="text/javascript" src="effective_files/job_reco(1).js"></SCRIPT>

<SCRIPT type="text/javascript">
         csdn.position.show({
         sourceType: "blog",
         tplType: "blogDetail",
         searchType: "detail",
         searchKey: "5601038",
             username: "",
         containerId: "job_blog_reco"
        }); 
    </SCRIPT>
</DIV>
<SCRIPT type="text/javascript">
    var searchtitletags = 'Effective C++读书笔记' + ',' + '读书笔记,c++,面向对象编程,内存泄露,设计模式';
    searchService({
        index: 'blog',
        query: searchtitletags,
        from: 5,
        size: 5,
        appendTo: '#res',
        url: 'recommend',
        his: 2,
        client: "blog_cf_enhance",
        tmpl: '<dd style="background:url(http://static.blog.csdn.net/skin/default/images/blog-dot-red3.gif) no-repeat 0 10px;"><a href="#{ url }" title="#{ title }" strategy="#{ strategy }">#{ title }</a></dd>'
    });

 </SCRIPT>

<DIV id="ad_cen">
<SCRIPT type="text/javascript">
              new Ad(4, 'ad_cen');
          </SCRIPT>
</DIV>
<DIV class="comment_class">
<DIV id="comment_title" class="panel_head"><SPAN 
class="see_comment">查看评论</SPAN><A name="comments"></A></DIV>
<DIV id="comment_list"></DIV>
<DIV id="comment_bar"></DIV>
<DIV id="comment_form"></DIV>
<DIV class="announce">* 以上用户言论只代表其个人观点，不代表CSDN网站的观点或立场<A name="reply"></A><A 
name="quote"></A></DIV></DIV>
<SCRIPT type="text/javascript">var fileName = '5601038';
    var commentscount = 3;
    var islock = false
</SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/comment.js"></SCRIPT>

<DIV id="ad_bot"></DIV>
<SCRIPT type="text/javascript">
    new Ad(5, 'ad_bot');
    </SCRIPT>

<DIV id="report_dialog"></DIV>
<DIV style="bottom: 60px;" id="d-top"><A style="display: none;" id="quick-reply" 
class="btn btn-top q-reply" title="快速回复"><IMG alt="快速回复" src="effective_files/blog-icon-reply.png"></A><A 
style="display: none;" id="d-top-a" class="btn btn-top backtop" title="返回顶部" 
onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_huidaodingbu'])"><IMG 
alt="TOP" src="effective_files/top.png"></A></DIV>
<SCRIPT type="text/javascript">
    $(function ()
    {
        $("#ad_frm_0").height("90px");
        
        setTimeout(function(){
            $("#ad_frm_2").height("200px");
        },1000);
        
        /*
        if($("#comment_content").length>0)
        {
            $("#quick-reply").show();

            $("#quick-reply").click(function(){
                setEditorFocus();
            });
        }       
     
        var d_top = $('#d-top-a');

        document.onscroll = function ()
        {
            var scrTop = (document.body.scrollTop || document.documentElement.scrollTop);
            if (scrTop > 500)
            {
                d_top.show();
            } else
            {
                d_top.hide();
            }
        }
        $('#d-top-a').click(function ()
        {
            scrollTo(0, 0);
            this.blur();
            return false;
        });
        */
    });
  
</SCRIPT>

<STYLE type="text/css">
    .tag_list
    {
        background: none repeat scroll 0 0 #FFFFFF;
        border: 1px solid #D7CBC1;
        color: #000000;
        font-size: 12px;
        line-height: 20px;
        list-style: none outside none;
        margin: 10px 2% 0 1%;
        padding: 1px;
    }
    .tag_list h5
    {
        background: none repeat scroll 0 0 #E0DBD3;
        color: #47381C;
        font-size: 12px;
        height: 24px;
        line-height: 24px;
        padding: 0 5px;
        margin: 0;
    }
    .tag_list h5 a
    {
        color: #47381C;
    }
    .classify
    {
        margin: 10px 0;
        padding: 4px 12px 8px;
    }
    .classify a
    {
        margin-right: 20px;
        white-space: nowrap;
    }
</STYLE>

<DIV class="tag_list">
<H5><A href="http://www.csdn.net/tag/" target="_blank">核心技术类目</A></H5>
<DIV class="classify"><A title="全部主题" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag" 
target="_blank">全部主题</A><A title="Hadoop" onclick="LogClickCount(this,336);" 
href="http://g.csdn.net/5272865" target="_blank">Hadoop</A><A title="AWS" 
onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272866" target="_blank">AWS</A>
<A title="移动游戏" onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272870" 
target="_blank">移动游戏</A><A title="Java" onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272871" 
target="_blank">Java</A><A title="Android" onclick="LogClickCount(this,336);" 
href="http://g.csdn.net/5272872" target="_blank">Android</A><A title="iOS" 
onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272873" target="_blank">iOS</A>
<A title="Swift" onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272868" 
target="_blank">Swift</A><A title="智能硬件" onclick="LogClickCount(this,336);" 
href="http://g.csdn.net/5272869" target="_blank">智能硬件</A><A title="Docker" 
onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272867" target="_blank">Docker</A>
<A title="OpenStack" onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272925" 
target="_blank">OpenStack</A><A title="VPN" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/vpn" target="_blank">VPN</A><A title="Spark" 
onclick="LogClickCount(this,336);" href="http://g.csdn.net/5272924" target="_blank">Spark</A>
<A title="ERP" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/erp" 
target="_blank">ERP</A><A title="IE10" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/ie10" 
target="_blank">IE10</A><A title="Eclipse" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/eclipse" target="_blank">Eclipse</A><A title="CRM" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/crm" target="_blank">CRM</A>
<A title="JavaScript" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/javascript" 
target="_blank">JavaScript</A><A title="数据库" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/数据库" target="_blank">数据库</A><A title="Ubuntu" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/ubuntu" target="_blank">Ubuntu</A>
<A title="NFC" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/nfc" 
target="_blank">NFC</A><A title="WAP" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/wap" 
target="_blank">WAP</A><A title="jQuery" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/jquery" target="_blank">jQuery</A><A title="BI" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/bi" target="_blank">BI</A>
<A title="HTML5" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/html5" 
target="_blank">HTML5</A><A title="Spring" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/spring" target="_blank">Spring</A><A title="Apache" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/apache" target="_blank">Apache</A>
<A title=".NET" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/.net" 
target="_blank">.NET</A><A title="API" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/api" 
target="_blank">API</A><A title="HTML" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/html" 
target="_blank">HTML</A><A title="SDK" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/sdk" 
target="_blank">SDK</A><A title="IIS" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/iis" 
target="_blank">IIS</A><A title="Fedora" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/fedora" target="_blank">Fedora</A><A title="XML" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/xml" target="_blank">XML</A>
<A title="LBS" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/lbs" 
target="_blank">LBS</A><A title="Unity" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/unity" 
target="_blank">Unity</A><A title="Splashtop" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/splashtop" target="_blank">Splashtop</A><A title="UML" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/uml" target="_blank">UML</A>
<A title="components" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/components" 
target="_blank">components</A><A title="Windows Mobile" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/windowsmobile" target="_blank">Windows Mobile</A>
<A title="Rails" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/rails" 
target="_blank">Rails</A><A title="QEMU" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/qemu" target="_blank">QEMU</A><A title="KDE" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/kde" target="_blank">KDE</A>
<A title="Cassandra" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/cassandra" 
target="_blank">Cassandra</A><A title="CloudStack" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/cloudstack" target="_blank">CloudStack</A><A 
title="FTC" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/ftc" 
target="_blank">FTC</A><A title="coremail" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/coremail" target="_blank">coremail</A><A title="OPhone " 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/ophone" target="_blank">OPhone 
</A><A title="CouchBase" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/couchbase" 
target="_blank">CouchBase</A><A title="云计算" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/云计算" target="_blank">云计算</A><A title="iOS6" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/iOS6" target="_blank">iOS6</A>
<A title="Rackspace " onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/rackspace" 
target="_blank">Rackspace </A><A title="Web App" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/webapp" target="_blank">Web App</A><A title="SpringSide" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/springside" 
target="_blank">SpringSide</A><A title="Maemo" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/maemo" target="_blank">Maemo</A><A title="Compuware" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/compuware" 
target="_blank">Compuware</A><A title="大数据" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/大数据" target="_blank">大数据</A><A title="aptech" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/aptech" target="_blank">aptech</A>
<A title="Perl" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/perl" 
target="_blank">Perl</A><A title="Tornado" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/tornado" target="_blank">Tornado</A><A title="Ruby" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/ruby" target="_blank">Ruby</A>
<A title="Hibernate" onclick="LogClickCount(this,336);" href="http://www.csdn.net/hibernate" 
target="_blank">Hibernate</A><A title="ThinkPHP" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/thinkphp" target="_blank">ThinkPHP</A><A title="HBase" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/hbase" target="_blank">HBase</A>
<A title="Pure" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/pure" 
target="_blank">Pure</A><A title="Solr" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/solr" 
target="_blank">Solr</A><A title="Angular" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/angular" target="_blank">Angular</A><A title="Cloud Foundry" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/cloudfoundry" 
target="_blank">Cloud Foundry</A><A title="Redis" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/redis" target="_blank">Redis</A><A title="Scala" 
onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/scala" target="_blank">Scala</A>
<A title="Django" onclick="LogClickCount(this,336);" href="http://www.csdn.net/tag/django" 
target="_blank">Django</A><A title="Bootstrap" onclick="LogClickCount(this,336);" 
href="http://www.csdn.net/tag/bootstrap" target="_blank">Bootstrap</A></DIV>
</DIV>
<DIV style="background: 0px 0px rgb(255, 255, 255); border: 1px solid rgb(220, 220, 220); left: 630px; top: 222.5px; display: none; position: absolute; z-index: 10000; opacity: 1;" 
id="pop_win"></DIV>
<DIV id="popup_mask"></DIV>
<STYLE>
    #popup_mask
    {
        position: absolute;
        width: 100%;
        height: 100%;
        background: #000;
        z-index: 9999;
        left: 0px;
        top: 0px;
        opacity: 0.3;
        filter: alpha(opacity=30);
        display: none;
    }

</STYLE>

<SCRIPT type="text/javascript">
    $(function(){
        setTimeout(function(){
            $(".comment_body:contains('回复')").each(function(index,item){
                var u=$(this).text().split('：')[0].toString().replace("回复","")
                var thisComment=$(this);
                if(u)
                {
                    $.getJSON("https://passport.csdn.net/get/nick?callback=?", {users: u}, function(a) {
                        if(a!=null&&a.data!=null&&a.data.length>0)
                        {
                            nick=a.data[0].n; 
                            if(u!=nick)
                            {
                                thisComment.text(thisComment.text().replace(u,nick));  
                            }
                        }       
                    });  
                }
            });
        },200);  
        
        setTimeout(function(){
            $("a img[src='http://js.tongji.linezing.com/stats.gif']").parent().css({"position":"absolute","left":"50%"});
        },300);
    });

    function loginbox(){
        var $logpop=$("#pop_win");
        $logpop.html('<iframe src="https://passport.csdn.net/account/loginbox?service=http://static.blog.csdn.net/callback.htm" frameborder="0" height="600" width="400" scrolling="no"></iframe>');

        $('#popup_mask').css({
            opacity: 0.5,
            width: $( document ).width() + 'px',
            height:  $( document ).height() + 'px'
        });
        $('#popup_mask').css("display","block");
 
        $logpop.css( {
            top: ($( window ).height() - $logpop.height())/ 2  + $( window 
       ).scrollTop() + 'px',
            left:($( window ).width() - $logpop.width())/ 2
        } );
 
        setTimeout( function () {
            $logpop.show();
            $logpop.css( {
                opacity: 1
            } );
        }, 200 );
 
        $('#popup_mask').unbind("click");
        $('#popup_mask').bind("click", function(){
            $('#popup_mask').hide();
            var $clopop = $("#pop_win");
            $("#common_ask_div_sc").css("display","none");
            $clopop.css( {
                opacity: 0
            } );
            setTimeout( function () {
                $clopop.hide();
            }, 350 );
            return false;
        });
    }    

</SCRIPT>

<DIV class="clear"></DIV></DIV></DIV>
<DIV id="side">
<DIV class="side">
<DIV id="panel_Profile" class="panel">
<UL class="panel_head"><SPAN>个人资料</SPAN></UL>
<UL class="panel_body profile">
  <DIV id="blog_userface"><A href="http://my.csdn.net/shenzi" 
  target="_blank"><IMG style="max-width: 90%;" title="访问我的空间" src="effective_files/1_shenzi.jpg"></A><BR><SPAN><A 
  class="user_name" href="http://my.csdn.net/shenzi" 
  target="_blank">shenzi</A></SPAN></DIV>
  <DIV class="interact"><A id="span_add_follow" class="attent" title="[加关注]" 
  onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_guanzhu'])" 
  href="javascript:void(0);"></A><A class="letter" title="[发私信]" onclick="window.open('http://msg.csdn.net/letters/model?receiver=shenzi','_blank','height=350,width=700');_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_sixin'])" 
  href="javascript:void(0);"></A></DIV>
  <DIV id="blog_medal">
  <DIV id="bms_box"></DIV></DIV>
  <UL id="blog_rank">
    <LI>访问：<SPAN>109278次</SPAN></LI>
    <LI>积分：<SPAN>1608</SPAN> </LI>
    <LI>等级： <SPAN 
    style="display: inline-block; position: relative; z-index: 1;"><IMG style="vertical-align: middle;" 
    id="leveImg" alt="" src="effective_files/blog4.png">
    <DIV style="border: 2px solid rgb(221, 221, 221); left: -24px; top: 25px; width: 101px; height: 32px; text-align: center; line-height: 32px; display: none; position: absolute; z-index: 999; box-shadow: none; background-color: rgb(255, 255, 255);" 
    id="smallTittle">
    <DIV style="left: 42%; top: -8px; width: 0px; height: 0px; border-right-color: transparent; border-bottom-color: rgb(234, 234, 234); border-left-color: transparent; border-right-width: 10px; border-bottom-width: 8px; border-left-width: 10px; border-right-style: solid; border-bottom-style: solid; border-left-style: solid; position: absolute;"></DIV> 
               积分：1608 </DIV></SPAN></LI>
    <LI>排名：<SPAN>第12486名</SPAN></LI></UL>
  <UL id="blog_statistics">
    <LI>原创：<SPAN>43篇</SPAN></LI>
    <LI>转载：<SPAN>15篇</SPAN></LI>
    <LI>译文：<SPAN>0篇</SPAN></LI>
    <LI>评论：<SPAN>44条</SPAN></LI></UL></UL></DIV>
<DIV id="panel_Search" class="panel">
<UL class="panel_head"><SPAN>文章搜索</SPAN></UL>
<UL class="panel_body">
  <FORM id="frmSearch" class="form_search" action="http://so.csdn.net/search" 
  target="_blank"><SPAN><INPUT id="inputSearch" class="blogsearch" title="请输入关键字" 
  type="text"></SPAN><INPUT id="btnSubmit" title="search in blog" value="搜索" type="button"><INPUT 
  id="inputQ" name="q" type="hidden"><INPUT name="t" value="blog" 
  type="hidden"><A id="btnSearchBlog" target="_blank"></A></FORM></UL></DIV>
<SCRIPT type="text/javascript">
    $(function () {
        $("#btnSubmit").click(function () {           
            search();
        });

        $("#frmSearch").submit(function () {
            search();
            return false;
        });

        function search()
        {
            var url = "http://so.csdn.net/so/search/s.do?q=" + encodeURIComponent($("#inputSearch").val()) + "&u=" + username + "&t=blog";
            window.location.href = url;
        }   
    });
</SCRIPT>

<DIV id="panel_Category" class="panel">
<UL class="panel_head"><SPAN>文章分类</SPAN></UL>
<UL class="panel_body">
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/666999">3D 
  Programming</A><SPAN>(1)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/483047">C++</A><SPAN>(6)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/541105">Direct3D</A><SPAN>(10)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/583401">OSG</A><SPAN>(1)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/583402">VRPN</A><SPAN>(1)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/594099">Windows内核学习</A><SPAN>(2)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/520037">windows编程</A><SPAN>(24)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/479232">生活</A><SPAN>(6)</SPAN></LI>
  <LI><A onclick="_gaq.push(['_trackEvent','function', 'onclick', 'blog_articles_wenzhangfenlei']); " 
  href="http://blog.csdn.net/shenzi/article/category/521375">面向对象</A><SPAN>(2)</SPAN></LI>
</UL></DIV>
<DIV id="panel_Archive" class="panel">
<UL class="panel_head"><SPAN>文章存档</SPAN></UL>
<UL class="panel_body">
  <DIV id="archive_list"><!--归档统计-->
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2010/06">2010年06月</A><SPAN>(1)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2010/05">2010年05月</A><SPAN>(2)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2010/03">2010年03月</A><SPAN>(1)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2010/01">2010年01月</A><SPAN>(3)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/12">2009年12月</A><SPAN>(2)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/10">2009年10月</A><SPAN>(11)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/09">2009年09月</A><SPAN>(11)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/08">2009年08月</A><SPAN>(2)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/07">2009年07月</A><SPAN>(2)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/05">2009年05月</A><SPAN>(9)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/04">2009年04月</A><SPAN>(1)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2009/03">2009年03月</A><SPAN>(8)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2008/12">2008年12月</A><SPAN>(1)</SPAN></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/month/2008/11">2008年11月</A><SPAN>(4)</SPAN></LI>
  </DIV></UL></DIV>
<DIV id="hotarticls" class="panel">
<UL class="panel_head"><SPAN>阅读排行    </SPAN></UL>
<UL class="panel_body itemlist">
  <LI><A title=" 3D图形渲染管线 " href="http://blog.csdn.net/shenzi/article/details/5417488"> 
  3D图形渲染管线 </A><SPAN>(8466)</SPAN></LI>
  <LI><A title="Windows核心编程：DLL注入和API拦截" href="http://blog.csdn.net/shenzi/article/details/4739746">Windows核心编程：DLL注入和API拦截</A><SPAN>(6878)</SPAN>
  </LI>
  <LI><A title="Effective C++读书笔记" href="http://blog.csdn.net/shenzi/article/details/5601038">Effective 
  C++读书笔记</A><SPAN>(6699)</SPAN></LI>
  <LI><A title="VRPN介绍及使用" href="http://blog.csdn.net/shenzi/article/details/4470995">VRPN介绍及使用</A><SPAN>(5345)</SPAN>
  </LI>
  <LI><A title="李践《高效人士的五项管理-行动日志》 表格" href="http://blog.csdn.net/shenzi/article/details/3947134">李践《高效人士的五项管理-行动日志》 
  表格</A><SPAN>(4666)</SPAN></LI>
  <LI><A title="Windows内核学习：OS体系结构" href="http://blog.csdn.net/shenzi/article/details/4561127">Windows内核学习：OS体系结构</A><SPAN>(3808)</SPAN>
  </LI>
  <LI><A title="OSG源码编译" href="http://blog.csdn.net/shenzi/article/details/5269946">OSG源码编译</A><SPAN>(3300)</SPAN>
  </LI>
  <LI><A title="Windows内核学习：I/O系统" href="http://blog.csdn.net/shenzi/article/details/4657216">Windows内核学习：I/O系统</A><SPAN>(3225)</SPAN>
  </LI>
  <LI><A title="致加西亚的信 名言佳句 " href="http://blog.csdn.net/shenzi/article/details/5653720">致加西亚的信 
  名言佳句 </A><SPAN>(2596)</SPAN></LI>
  <LI><A title="Writing Stereoscopic Software for StereoGraphics® Systems Using Microsoft Windows® OpenGL" 
  href="http://blog.csdn.net/shenzi/article/details/4395145">Writing 
  Stereoscopic Software for StereoGraphics® Systems Using Microsoft Windows® 
  OpenGL</A><SPAN>(2429)</SPAN></LI></UL></DIV>
<DIV id="hotarticls2" class="panel">
<UL class="panel_head"><SPAN>评论排行</SPAN></UL>
<UL class="panel_body itemlist">
  <LI><A title=" 3D图形渲染管线 " href="http://blog.csdn.net/shenzi/article/details/5417488"> 
  3D图形渲染管线 </A><SPAN>(6)</SPAN></LI>
  <LI><A title="七巧板 Chi7ren V0.1" href="http://blog.csdn.net/shenzi/article/details/5014014">七巧板 
  Chi7ren V0.1</A><SPAN>(5)</SPAN></LI>
  <LI><A title="Windows核心编程：线程基础" href="http://blog.csdn.net/shenzi/article/details/4590011">Windows核心编程：线程基础</A><SPAN>(4)</SPAN>
  </LI>
  <LI><A title="Windows核心编程：同步设备I/O与异步设备I/O" href="http://blog.csdn.net/shenzi/article/details/4648579">Windows核心编程：同步设备I/O与异步设备I/O</A><SPAN>(3)</SPAN>
  </LI>
  <LI><A title="Effective C++读书笔记" href="http://blog.csdn.net/shenzi/article/details/5601038">Effective 
  C++读书笔记</A><SPAN>(3)</SPAN></LI>
  <LI><A title="Windows核心编程：内存体系结构" href="http://blog.csdn.net/shenzi/article/details/4662420">Windows核心编程：内存体系结构</A><SPAN>(3)</SPAN>
  </LI>
  <LI><A title="Windows核心编程：内核对象" href="http://blog.csdn.net/shenzi/article/details/4570964">Windows核心编程：内核对象</A><SPAN>(3)</SPAN>
  </LI>
  <LI><A title="李践《高效人士的五项管理-行动日志》 表格" href="http://blog.csdn.net/shenzi/article/details/3947134">李践《高效人士的五项管理-行动日志》 
  表格</A><SPAN>(3)</SPAN></LI>
  <LI><A title="Windows核心编程：用户模式下的线程同步" href="http://blog.csdn.net/shenzi/article/details/4609914">Windows核心编程：用户模式下的线程同步</A><SPAN>(2)</SPAN>
  </LI>
  <LI><A title="Windows核心编程：堆 " href="http://blog.csdn.net/shenzi/article/details/4689695">Windows核心编程：堆 
  </A><SPAN>(2)</SPAN></LI></UL></DIV>
<DIV id="homepageArticles" class="panel tracking-ad" data-mod="popu_4">
<UL class="panel_head"><SPAN>推荐文章</SPAN></UL>
<UL id="ad_commend" class="panel_body"></UL></DIV>
<SCRIPT type="text/javascript">new Ad(12, 'ad_commend');
</SCRIPT>

<DIV id="newcomments" class="panel">
<UL class="panel_head"><SPAN>最新评论</SPAN></UL>
<UL class="panel_body itemlist">
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/5601038#comments">Effective 
  C++读书笔记</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/dc_726">dc_726</A>:
  学习了！    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/5601038#comments">Effective 
  C++读书笔记</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/u011057726">u011057726</A>:
   const char * const authorName = "Flygend";博主有一处写错了    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/4689675#comments">Windows核心编程：内存映射文件</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/fallschool">fallschool</A>:
  当你有个锤子的时候，什么东西看起来都像是钉子！寻找自己的锤子----------妈的真有哲理    </P></LI>
  <LI><A href="http://blog.csdn.net/shenzi/article/details/5417488#comments"> 
  3D图形渲染管线 </A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/abeyondc">abeyondc</A>:
   LZ图挂了~~~还是我网络问题？    </P></LI>
  <LI><A href="http://blog.csdn.net/shenzi/article/details/5417488#comments"> 
  3D图形渲染管线 </A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/gggg_ggg">gggg_ggg</A>:
  太好的，找的就是这个    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/5417488#comments">Effective 
  C++读书笔记</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/lijian19911012">lijian19911012</A>:
  总结的不错，帮顶。    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/4570964#comments">Windows核心编程：内核对象</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/acmilanvanbasten">acmilanvanbasten</A>:
  不错    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/4662420#comments">Windows核心编程：内存体系结构</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/stafniejay">stafniejay</A>:
  内核对象是在用户模式分区还是在内核分区？    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/4662420#comments">Windows核心编程：内存体系结构</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/kitochou12">kitochou12</A>:
  博主你好，有两个问题想请教下：1. 内存区域类型中mapped和image两种类型的区别？2. 在内...    </P></LI>
  <LI><A 
  href="http://blog.csdn.net/shenzi/article/details/5269911#comments">COLLADA - 
  交互3D数字资产交换方案</A>
  <P style="margin: 0px;"><A class="user_name" href="http://blog.csdn.net/lin5165352">lin5165352</A>:
  赞一个    </P></LI></UL></DIV></DIV>
<DIV class="clear"></DIV></DIV>
<DIV class="clear"></DIV></DIV>
<SCRIPT type="text/javascript" src="effective_files/cnick.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/newblog.min.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/showblogmedal.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/JavaScript1.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/login.js"></SCRIPT>

<SCRIPT type="text/javascript">document.write("<img src=http://counter.csdn.net/pv.aspx?id=24 border=0 width=0 height=0>");</SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/counter.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/ad-blog.js"></SCRIPT>

<SCRIPT type="text/javascript" src="effective_files/count.js"></SCRIPT>

<SCRIPT type="text/javascript">
    $(function () {
        function __get_code_toolbar(snippet_id) {
            return $("<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "' target='_blank' title='在CODE上查看代码片' style='text-indent:0;'><img src='https://code.csdn.net/assets/CODE_ico.png' width=12 height=12 alt='在CODE上查看代码片' style='position:relative;top:1px;left:2px;'/></a>"
                    + "<a href='https://code.csdn.net/snippets/"
                    + snippet_id
                    + "/fork' target='_blank' title='派生到我的代码片'  style='text-indent:0;'><img src='https://code.csdn.net/assets/ico_fork.svg' width=12 height=12 alt='派生到我的代码片' style='position:relative;top:2px;left:2px;'/></a>");
        }
        
        $("[code_snippet_id]").each(function () {
            __s_id = $(this).attr("code_snippet_id");
            if (__s_id != null && __s_id != "" && __s_id != 0 && parseInt(__s_id) > 70020) {
                __code_tool = __get_code_toolbar(__s_id);
                $(this).prev().find(".tools").append(__code_tool);
            }
        });
    });
</SCRIPT>
</DIV><!--new top-->
<SCRIPT id="csdn-toolbar-id" type="text/javascript" src="effective_files/toolbar.js" subCount="5" count="5" wrapId="note1" btnId="header_notice_num"></SCRIPT>
<!--new top--><LINK rel="stylesheet" type="text/css" href="effective_files/ask_float_block.css">
<SCRIPT language="JavaScript" type="text/javascript" src="effective_files/wmd.js"></SCRIPT>

<SCRIPT language="JavaScript" type="text/javascript" src="effective_files/showdown.js"></SCRIPT>

<SCRIPT language="JavaScript" type="text/javascript" src="effective_files/prettify.js"></SCRIPT>

<SCRIPT language="JavaScript" type="text/javascript" src="effective_files/ask_float_block.js"></SCRIPT>
</BODY></HTML>
