<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0049)http://www.cnblogs.com/liangliangh/p/4219879.html -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-cn"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script async="" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/4219879"></script><script async="" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/analytics.js"></script><script async="" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/postmoduletext"></script>

<title>C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园</title>
<link type="text/css" rel="stylesheet" href="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/blog-common.css">
<link id="MainCss" type="text/css" rel="stylesheet" href="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/bundle-kubrick.css">
<link type="text/css" rel="stylesheet" href="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/151287.css">
<link title="RSS" type="application/rss+xml" rel="alternate" href="http://www.cnblogs.com/liangliangh/rss">
<link title="RSD" type="application/rsd+xml" rel="EditURI" href="http://www.cnblogs.com/liangliangh/rsd.xml">
<link type="application/wlwmanifest+xml" rel="wlwmanifest" href="http://www.cnblogs.com/liangliangh/wlwmanifest.xml">
<script async="" type="text/javascript" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/gpt.js"></script><script src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/jquery.js" type="text/javascript"></script>  
<script type="text/javascript">var currentBlogApp = 'liangliangh', cb_enable_mathjax=false;</script>
<script src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/blog-common.js" type="text/javascript"></script>
</head>
<body>
<a name="top"></a>

<div id="header">
    
<h1><a id="Header1_HeaderTitle" class="headermaintitle" href="http://www.cnblogs.com/liangliangh/">亮亮的园子</a></h1>
<p id="tagline">一个具有学术气质的IT技术博客</p>
</div>
<div id="wrapper">
<div id="main">
    

	<div class="post">
		<h2>
			<a id="cb_post_title_url" href="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园.htm">C++模板元编程（C++ template metaprogramming）</a>
		</h2>
		<div class="postText"><div id="cnblogs_post_body"><p>&nbsp;</p>
<p>实验平台：Win7，VS2013 Community，GCC 4.8.3（在线版）</p>
<p>&nbsp;</p>
<p>所谓元编程就是编写直接生成或操纵程序的程序，C++ 模板给 C++ 语言提供了元编程的能力，模板使 C++ 编程变得异常灵活，能实现很多高级动态语言才有的特性（语法上可能比较丑陋，一些历史原因见下文）。普通用户对 C++ 模板的使用可能不是很频繁，大致限于泛型编程，但一些系统级的代码，尤其是对通用性、性能要求极高的基础库（如 STL、Boost）几乎不可避免的都大量地使用 C++ 模板，一个稍有规模的大量使用模板的程序，不可避免的要涉及元编程（如类型计算）。本文就是要剖析 C++ 模板元编程的机制。</p>
<p>&nbsp;</p>
<p><span style="color: #ff0000;">下面所给的所有代码，想做实验又懒得打开编译工具？</span><span style="color: #000000;">一个</span><a href="http://www.tutorialspoint.com/compile_cpp11_online.php">在线运行 C++ 代码的网站（GCC 4.8）</a>很好~</p>
<p>（本博文地址：http://www.cnblogs.com/liangliangh/p/4219879.html，转载版本将得不到作者维护）&nbsp;</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: large;">1. C++模板的语法</span></strong></p>
<p><strong><span style="color: #ff0000;">函数模板</span></strong>（function template）和<strong><span style="color: #ff0000;">类模板</span></strong>（class template）的简单示例如下：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: green;">// 函数模板
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">bool </span><span style="color: black;">equivalent(</span><span style="color: blue;">const </span><span style="color: #2b91af;">T</span><span style="color: black;">&amp; </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">const </span><span style="color: #2b91af;">T</span><span style="color: black;">&amp; </span><span style="color: gray;">b</span><span style="color: black;">){
    </span><span style="color: blue;">return </span><span style="color: black;">!(</span><span style="color: gray;">a </span><span style="color: black;">&lt; </span><span style="color: gray;">b</span><span style="color: black;">) &amp;&amp; !(</span><span style="color: gray;">b </span><span style="color: black;">&lt; </span><span style="color: gray;">a</span><span style="color: black;">);
}
</span><span style="color: green;">// 类模板
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">=</span><span style="color: blue;">int</span><span style="color: black;">&gt; </span><span style="color: green;">// 默认参数
</span><span style="color: blue;">class </span><span style="color: #2b91af;">bignumber</span><span style="color: black;">{
    </span><span style="color: #2b91af;">T </span><span style="color: black;">_v;
</span><span style="color: blue;">public</span><span style="color: black;">:
    bignumber(</span><span style="color: #2b91af;">T </span><span style="color: gray;">a</span><span style="color: black;">) : _v(</span><span style="color: gray;">a</span><span style="color: black;">) { }
    </span><span style="color: blue;">inline bool </span><span style="color: black;">operator&lt;(</span><span style="color: blue;">const </span><span style="color: #2b91af;">bignumber</span><span style="color: black;">&amp; b) </span><span style="color: blue;">const</span><span style="color: black;">; </span><span style="color: green;">// 等价于 (const bignumber&lt;T&gt;&amp; b)
</span><span style="color: black;">};
</span><span style="color: green;">// 在类模板外实现成员函数
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">bool </span><span style="color: #2b91af;">bignumber</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;::operator&lt;(</span><span style="color: blue;">const </span><span style="color: #2b91af;">bignumber</span><span style="color: black;">&amp; </span><span style="color: gray;">b</span><span style="color: black;">) </span><span style="color: blue;">const</span><span style="color: black;">{
    </span><span style="color: blue;">return </span><span style="color: black;">_v &lt; </span><span style="color: gray;">b</span><span style="color: black;">._v;
}

</span><span style="color: blue;">int </span><span style="color: black;">main()
{
    </span><span style="color: #2b91af;">bignumber</span><span style="color: black;">&lt;&gt; a(1), b(1); </span><span style="color: green;">// 使用默认参数，"&lt;&gt;"不能省略
    </span><span style="color: black;">std::cout &lt;&lt; equivalent(a, b) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; </span><span style="color: green;">// 函数模板参数自动推导
    </span><span style="color: black;">std::cout &lt;&lt; equivalent&lt;</span><span style="color: blue;">double</span><span style="color: black;">&gt;(1, 2) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get();    </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<p>程序输出如下：</p>
<pre class="console-cpp"><span style="color: black;">1
0</span></pre>
<p>关于模板（函数模板、类模板）的<strong><span style="color: #ff0000;">模板参数</span></strong>（详见文献[1]第3章）：</p>
<ul>
<li>类型参数（type template parameter），用 typename 或 class 标记；</li>
<li>非类型参数（non-type template parameter）可以是：整数及枚举类型、对象或函数的指针、对象或函数的引用、对象的成员指针，非类型参数是模板实例的常量；</li>
<li>模板型参数（template template parameter），如“template&lt;typename T, template&lt;typename&gt; class A&gt; someclass {};”；</li>
<li>模板参数可以有默认值（函数模板参数默认是从 C++11 开始支持）；</li>
<li>函数模板的和函数参数类型有关的模板参数可以自动推导，类模板参数不存在推导机制；</li>
<li>C++11 引入变长模板参数，请见下文。</li>
</ul>
<p><strong><span style="color: #ff0000;">模板特例化</span></strong>（template specialization，又称特例、特化）的简单示例如下：</p>
<pre class="code-cpp"><span style="color: green;">// 实现一个向量类
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">N&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">Vec</span><span style="color: black;">{
    </span><span style="color: #2b91af;">T </span><span style="color: black;">_v[N];
    </span><span style="color: green;">// ... // 模板通例（primary template），具体实现
</span><span style="color: black;">};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">Vec</span><span style="color: black;">&lt;</span><span style="color: blue;">float</span><span style="color: black;">, 4&gt;{
    </span><span style="color: blue;">float </span><span style="color: black;">_v[4];
    </span><span style="color: green;">// ... // 对 Vec&lt;float, 4&gt; 进行专门实现，如利用向量指令进行加速
</span><span style="color: black;">};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">N&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">Vec</span><span style="color: black;">&lt;</span><span style="color: blue;">bool</span><span style="color: black;">, N&gt;{
    </span><span style="color: blue;">char </span><span style="color: black;">_v[(N+</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: blue;">char</span><span style="color: black;">)-1)/</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: blue;">char</span><span style="color: black;">)];
    </span><span style="color: green;">// ... // 对 Vec&lt;bool, N&gt; 进行专门实现，如用一个比特位表示一个bool
</span><span style="color: black;">};</span></pre>
<p>所谓模板特例化即对于通例中的某种或某些情况做单独专门实现，最简单的情况是对每个模板参数指定一个具体值，这成为完全特例化（full specialization），另外，可以限制模板参数在一个范围取值或满足一定关系等，这称为部分特例化（partial specialization），用数学上集合的概念，通例模板参数所有可取的值组合构成全集U，完全特例化对U中某个元素进行专门定义，部分特例化对U的某个真子集进行专门定义。</p>
<p>更多模板特例化的例子如下（参考了文献[1]第44页）：</p>
<pre class="code-cpp"><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">cp00</span><span style="color: black;">; </span><span style="color: green;">// 用于模板型模板参数
// 通例
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">CP</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">TMP</span><span style="color: black;">;
</span><span style="color: green;">// 完全特例化
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">TMP</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">float</span><span style="color: black;">, 2, </span><span style="color: #2b91af;">cp00</span><span style="color: black;">&gt;;
</span><span style="color: green;">// 第一个参数有const修饰
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">CP</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">TMP</span><span style="color: black;">&lt;</span><span style="color: blue;">const </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">, i, </span><span style="color: #2b91af;">CP</span><span style="color: black;">&gt;;
</span><span style="color: green;">// 第一二个参数为cp00的实例且满足一定关系，第四个参数为cp00
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">TMP</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">cp00</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, i&gt;, </span><span style="color: #2b91af;">cp00</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, i+10&gt;, i, </span><span style="color: #2b91af;">cp00</span><span style="color: black;">&gt;;
</span><span style="color: green;">// 编译错误!，第四个参数类型和通例类型不一致
//template&lt;template&lt;int i&gt; CP&gt;
//class TMP&lt;int, float, 10, CP&gt;;</span></pre>
<p>关于模板特例化（详见文献[1]第4章）：</p>
<ul>
<li>在定义模板特例之前必须已经有模板通例（primary template）的声明；</li>
<li>模板特例并不要求一定与通例有相同的接口，但为了方便使用（体会特例的语义）一般都相同；</li>
<li>匹配规则，在模板实例化时如果有模板通例、特例加起来多个模板版本可以匹配，则依据如下规则：对版本AB，如果 A 的模板参数取值集合是B的真子集，则优先匹配 A，如果 AB 的模板参数取值集合是“交叉”关系（AB 交集不为空，且不为包含关系），则发生编译错误，对于函数模板，用函数重载分辨（overload resolution）规则和上述规则结合并优先匹配非模板函数。</li>
</ul>
<p>对模板的多个实例，<strong><span style="color: #ff0000;">类型等价</span></strong>（type equivalence）判断规则（详见文献[2] 13.2.4）：同一个模板（模板名及其参数类型列表构成的模板签名（template signature）相同，函数模板可以重载，类模板不存在重载）且指定的模板实参等价（类型参数是等价类型，非类型参数值相同）。如下例子：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: green;">// 识别两个类型是否相同，提前进入模板元编程^_^
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; </span><span style="color: green;">// 通例，返回 false
</span><span style="color: blue;">class </span><span style="color: #2b91af;">theSameType       </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">false </span><span style="color: black;">}; };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;               </span><span style="color: green;">// 特例，两类型相同时返回 true
</span><span style="color: blue;">class </span><span style="color: #2b91af;">theSameType</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">true </span><span style="color: black;">}; };

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">aTMP </span><span style="color: black;">{ };

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    </span><span style="color: blue;">typedef unsigned int </span><span style="color: #2b91af;">uint</span><span style="color: black;">; </span><span style="color: green;">// typedef 定义类型别名而不是引入新类型
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">uint uint2</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">theSameType</span><span style="color: black;">&lt;</span><span style="color: blue;">unsigned</span><span style="color: black;">, </span><span style="color: #2b91af;">uint2</span><span style="color: black;">&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    </span><span style="color: green;">// 感谢 C++11，连续角括号“&gt;&gt;”不会被当做流输入符号而编译错误
    </span><span style="color: black;">std::cout &lt;&lt; </span><span style="color: #2b91af;">theSameType</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;</span><span style="color: blue;">unsigned</span><span style="color: black;">, 2&gt;, </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">uint2</span><span style="color: black;">, 2&gt;&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">theSameType</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, 2&gt;, </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, 3&gt;&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}
</span></pre>
<pre class="console-cpp"><span style="color: black;">1
1
0</span></pre>
<p>关于<strong><span style="color: #ff0000;">模板实例化</span></strong>（template instantiation）（详见文献[4]模板）：</p>
<ul>
<li>指在编译或链接时生成函数模板或类模板的具体实例源代码，即用使用模板时的实参类型替换模板类型参数（还有非类型参数和模板型参数）；</li>
<li>隐式实例化（implicit instantiation）：当使用实例化的模板时自动地在当前代码单元之前插入模板的实例化代码，模板的成员函数一直到引用时才被实例化；</li>
<li>显式实例化（explicit instantiation）：直接声明模板实例化，模板所有成员立即都被实例化；</li>
<li>实例化也是一种特例化，被称为实例化的特例（instantiated (or generated) specialization）。</li>
</ul>
<p>隐式实例化时，成员只有被引用到才会进行实例化，这被称为推迟实例化（lazy instantiation），由此可能带来的问题如下面的例子（文献[6]，文献[7]）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">aTMP </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">void </span><span style="color: black;">f1() { std::cout &lt;&lt; </span><span style="color: #a31515;">"f1()\n"</span><span style="color: black;">; }
    </span><span style="color: blue;">void </span><span style="color: black;">f2() { std::ccccout &lt;&lt; </span><span style="color: #a31515;">"f2()\n"</span><span style="color: black;">; } </span><span style="color: green;">// 敲错键盘了，语义错误：没有 std::ccccout
</span><span style="color: black;">};

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; a;
    a.f1();
    </span><span style="color: green;">// a.f2(); // 这句代码被注释时，aTMP&lt;int&gt;::f2() 不被实例化，从而上面的错误被掩盖!
    </span><span style="color: black;">std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<p>所以模板代码写完后最好写个诸如显示实例化的测试代码，更深入一些，可以插入一些模板调用代码使得编译器及时发现错误，而不至于报出无限长的错误信息。另一个例子如下（GCC 4.8 下编译的输出信息，VS2013 编译输出了 500 多行错误信息）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: green;">// 计算 N 的阶乘 N!
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">N&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = N==0 ? 1 : N * </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;N-1&gt;::ret }; </span><span style="color: green;">// Lazy Instantiation，将产生无限递归!</span>
};

<span style="color: blue;">int </span><span style="color: black;">main(){
    std::cout &lt;&lt; </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;10&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">sh-4.2# g++ -std=c++11 -o main *.cpp
main.cpp:7:28: error: template instantiation depth exceeds maximum of 900 (use -ftemplate-depth= to increase the maximum) instantiating 'class aTMP&lt;-890&gt;'
  enum { ret = N==0 ? 1 : N * aTMP&lt;N-1&gt;::ret };
                            ^
main.cpp:7:28:   recursively required from 'class aTMP&lt;9&gt;'
main.cpp:7:28:   required from 'class aTMP&lt;10&gt;'
main.cpp:11:23:   required from here

main.cpp:7:28: error: incomplete type 'aTMP&lt;-890&gt;' used in nested name specifier</span></pre>
<p>上面的错误是因为，当编译 aTMP&lt;N&gt; 时，并不判断 N==0，而仅仅知道其依赖 aTMP&lt;N-1&gt;（lazy instantiation），从而产生无限递归，纠正方法是使用模板特例化，如下：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: green;">// 计算 N 的阶乘 N!
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">N&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = N * </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;N-1&gt;::ret };
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;0&gt;{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">enum </span><span style="color: black;">{ </span><span style="color: #2f4f4f;">ret </span><span style="color: black;">= 1 };
};

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    std::cout &lt;&lt; </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;10&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">3228800</span></pre>
<p>关于模板的<strong><span style="color: #ff0000;">编译和链接</span></strong>（详见文献[1] 1.3、文献[4]模板）：</p>
<ul>
<li>包含模板编译模式：编译器生成每个编译单元中遇到的所有的模板实例，并存放在相应的目标文件中；链接器合并等价的模板实例，生成可执行文件，要求实例化时模板定义可见，不能使用系统链接器；</li>
<li>分离模板编译模式（使用 export 关键字）：不重复生成模板实例，编译器设计要求高，可以使用系统链接器；</li>
<li>包含编译模式是主流，C++11 已经弃用 export 关键字（对模板引入 extern 新用法），一般将模板的全部实现代码放在同一个头文件中并在用到模板的地方用 #include 包含头文件，以防止出现实例不一致（如下面紧接着例子）；</li>
</ul>
<p>实例化，编译链接的简单例子如下（参考了文献[1]第10页）：</p>
<pre class="code-cpp"><span style="color: green;">// file: a.cpp
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">MyClass </span><span style="color: black;">{ };
</span><span style="color: blue;">template </span><span style="color: #2b91af;">MyClass</span><span style="color: black;">&lt;</span><span style="color: blue;">double</span><span style="color: black;">&gt;::MyClass(); </span><span style="color: green;">// 显示实例化构造函数 MyClass&lt;double&gt;::MyClass()
</span><span style="color: blue;">template class </span><span style="color: #2b91af;">MyClass</span><span style="color: black;">&lt;</span><span style="color: blue;">long</span><span style="color: black;">&gt;;        </span><span style="color: green;">// 显示实例化整个类 MyClass&lt;long&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">void </span><span style="color: black;">print(</span><span style="color: #2b91af;">T </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">m</span><span style="color: black;">) { std::cout &lt;&lt; </span><span style="color: #a31515;">"a.cpp: " </span><span style="color: black;">&lt;&lt; </span><span style="color: gray;">m </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; }

</span><span style="color: blue;">void </span><span style="color: black;">fa() {
    print(1);   </span><span style="color: green;">// print&lt;int&gt;，隐式实例化
    </span><span style="color: black;">print(0.1); </span><span style="color: green;">// print&lt;double&gt;
</span><span style="color: black;">}
</span><span style="color: blue;">void </span><span style="color: black;">fb(); </span><span style="color: green;">// fb() 在 b.cpp 中定义，此处声明

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    fa();
    fb();
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}
</span></pre>
<pre class="code-cpp"><span style="color: green;">// file: b.cpp
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">void </span><span style="color: black;">print(</span><span style="color: #2b91af;">T </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">m</span><span style="color: black;">) { std::cout &lt;&lt; </span><span style="color: #a31515;">"b.cpp: " </span><span style="color: black;">&lt;&lt; </span><span style="color: gray;">m </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; }

</span><span style="color: blue;">void </span><span style="color: black;">fb() {
    print(</span><span style="color: #a31515;">'2'</span><span style="color: black;">); </span><span style="color: green;">// print&lt;char&gt;
    </span><span style="color: black;">print(0.1); </span><span style="color: green;">// print&lt;double&gt;
</span><span style="color: black;">}</span></pre>
<pre class="console-cpp"><span style="color: black;">a.cpp: 1
a.cpp: 0.1
b.cpp: 2
a.cpp: 0.1</span></pre>
<p>上例中，由于 a.cpp 和 b.cpp 中的 print&lt;double&gt; 实例等价（模板实例的二进制代码在编译生成的对象文件 a.obj、b.obj 中），故链接时消除了一个（消除哪个没有规定，上面消除了 b.cpp 中的）。</p>
<p>关于 <strong><span style="color: #ff0000;">template、typename、this 关键字</span></strong>的使用（文献[4]模板，文献[5]）：</p>
<ul>
<li>依赖于模板参数（template parameter，形式参数，实参英文为 argument）的名字被称为依赖名字（dependent name），C++标准规定，如果解析器在一个模板中遇到一个嵌套依赖名字，它假定那个名字不是一个类型，除非显式用 typename 关键字前置修饰该名字；</li>
<li>和上一条 typename 用法类似，template 用于指明嵌套类型或函数为模板；</li>
<li>this 用于指定查找基类中的成员（当基类是依赖模板参数的类模板实例时，由于实例化总是推迟，这时不依赖模板参数的名字不在基类中查找，文献[1]第 166 页）。</li>
</ul>
<p>一个例子如下（需要 GCC 编译，GCC 对 C++11 几乎全面支持，VS2013 此处总是在基类中查找名字，且函数模板前不需要 template）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">aTMP</span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef const </span><span style="color: #2b91af;">T reType</span><span style="color: black;">;
};

</span><span style="color: blue;">void </span><span style="color: black;">f() { std::cout &lt;&lt; </span><span style="color: #a31515;">"global f()\n"</span><span style="color: black;">; }

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">Base </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">N = 99&gt;
    </span><span style="color: blue;">void </span><span style="color: black;">f() { std::cout &lt;&lt; </span><span style="color: #a31515;">"member f(): " </span><span style="color: black;">&lt;&lt; N &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; }
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">Derived </span><span style="color: black;">: </span><span style="color: blue;">public </span><span style="color: #2b91af;">Base</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">::</span><span style="color: #2b91af;">reType </span><span style="color: black;">m; <span style="color: green;">// typename 不能省略</span>
    Derived(</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">::</span><span style="color: #2b91af;">reType </span><span style="color: gray;">a</span><span style="color: black;">) : m(</span><span style="color: gray;">a</span><span style="color: black;">) { }
    </span><span style="color: blue;">void </span><span style="color: black;">df1() { f(); }                       </span><span style="color: green;">// 调用全局 f()，而非想象中的基类 f()
    </span><span style="color: blue;">void </span><span style="color: black;">df2() { </span><span style="color: blue;">this</span><span style="color: black;">-&gt;</span><span style="color: blue;">template </span><span style="color: black;">f(); }        </span><span style="color: green;">// 基类 f&lt;99&gt;()
    </span><span style="color: blue;">void </span><span style="color: black;">df3() { </span><span style="color: #2b91af;">Base</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;::</span><span style="color: blue;">template </span><span style="color: #2b91af;">f</span><span style="color: black;">&lt;22&gt;(); } </span><span style="color: green;">// 强制基类 f&lt;22&gt;()
    </span><span style="color: blue;">void </span><span style="color: black;">df4() { ::f(); }                     </span><span style="color: green;">// 强制全局 f()
</span><span style="color: black;">};

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    </span><span style="color: #2b91af;">Derived</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">aTMP</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;&gt; a(10);
    a.df1(); a.df2(); a.df3(); a.df4();
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">global f()
member f(): 99
member f(): 22
global f()</span></pre>
<p><strong><span style="color: #ff0000;">C++11 关于模板的新特性</span></strong><span style="color: #000000;">（详见文献[1]第15章，文献[4]C++11）</span>：</p>
<ul>
<li>“&gt;&gt;” 根据上下文自动识别正确语义；</li>
<li>函数模板参数默认值；</li>
<li>变长模板参数（扩展 sizeof...() 获取参数个数）；</li>
<li>模板别名（扩展 using 关键字）；</li>
<li>外部模板实例（拓展 extern 关键字），弃用 export template。</li>
</ul>
<p>在本文中，如无特别声明将不使用 C++11 的特性（除了 “&gt;&gt;”）。</p>
<p>&nbsp;</p>
<p><strong><span style="font-size: large;">2. 模板元编程概述</span></strong></p>
<p>如果对 C++ 模板不熟悉（光熟悉语法还不算熟悉），可以先跳过本节，往下看完例子再回来。</p>
<p>C++ 模板最初是为实现泛型编程设计的，但人们发现模板的能力远远不止于那些设计的功能。一个重要的理论结论就是：C++ 模板是<strong><span style="color: #ff0000;">图灵完备</span></strong>的（Turing-complete），其证明过程请见文献[8]（就是用 C++ 模板模拟图灵机），理论上说 C++ 模板可以执行任何计算任务，但实际上因为模板是编译期计算，其能力受到具体编译器实现的限制（如递归嵌套深度，C++11 要求至少 1024，C++98 要求至少 17）。C++ 模板元编程是“意外”功能，而不是设计的功能，这也是 C++ 模板元编程语法丑陋的根源。</p>
<p>C++ 模板是图灵完备的，这使得 C++ 成为<strong><span style="color: #ff0000;">两层次语言</span></strong>（two-level languages，中文暂且这么翻译，文献[9]），其中，执行编译计算的代码称为静态代码（static code），执行运行期计算的代码称为动态代码（dynamic code），C++ 的静态代码由模板实现（预处理的宏也算是能进行部分静态计算吧，也就是能进行部分元编程，称为宏元编程，见 Boost 元编程库即 BCCL，文献[16]和文献[1] 10.4）。</p>
<p>具体来说 C++ 模板可以做以下事情：编译期数值计算、类型计算、代码计算（如循环展开），其中数值计算实际不太有意义，而类型计算和代码计算可以使得代码更加通用，更加易用，性能更好（也更难阅读，更难调试，有时也会有代码膨胀问题）。编译期计算在编译过程中的位置请见下图（取自文献[10]），可以看到关键是模板的机制在编译具体代码（模板实例）前执行：</p>
<p><img style="display: inline;" title="C++ 模板元编程" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/131303575117915.png" alt="C++ 模板元编程" width="500" height="256"></p>
<p>从编程范型（programming paradigm）上来说，C++ 模板是<strong><span style="color: #ff0000;">函数式编程</span></strong>（functional programming），它的主要特点是：函数调用不产生任何副作用（没有可变的存储），用递归形式实现循环结构的功能。C++ 模板的特例化提供了条件判断能力，而模板递归嵌套提供了循环的能力，这两点使得其具有和普通语言一样通用的能力（图灵完备性）。</p>
<p>从<strong><span style="color: #ff0000;">编程形式</span></strong>来看，模板的“&lt;&gt;”中的模板参数相当于函数调用的输入参数，模板中的 typedef 或 static const 或 enum 定义函数返回值（类型或数值，数值仅支持整型，如果需要可以通过编码计算浮点数），代码计算是通过类型计算进而选择类型的函数实现的（C++ 属于静态类型语言，编译器对类型的操控能力很强）。代码示意如下：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i=1&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">someComputing </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef volatile </span><span style="color: #2b91af;">T</span><span style="color: black;">* </span><span style="color: #2b91af;">retType</span><span style="color: black;">; </span><span style="color: green;">// 类型计算
    </span><span style="color: blue;">enum </span><span style="color: black;">{ retValume = i + </span><span style="color: #2b91af;">someComputing</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, i-1&gt;::retValume }; </span><span style="color: green;">// 数值计算，递归
    </span><span style="color: blue;">static void </span><span style="color: black;">f() { std::cout &lt;&lt; </span><span style="color: #a31515;">"someComputing: i=" </span><span style="color: black;">&lt;&lt; i &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; }
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; </span><span style="color: green;">// 模板特例，递归终止条件
</span><span style="color: blue;">class </span><span style="color: #2b91af;">someComputing</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, 0&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">enum </span><span style="color: black;">{ retValume = 0 };
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">codeComputing </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static void </span><span style="color: black;">f() { </span><span style="color: #2b91af;">T</span><span style="color: black;">::f(); } </span><span style="color: green;">// 根据类型调用函数，代码计算
</span><span style="color: black;">};

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    </span><span style="color: #2b91af;">someComputing</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">retType </span><span style="color: black;">a=0;
    std::cout &lt;&lt; </span><span style="color: blue;">sizeof</span><span style="color: black;">(a) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; </span><span style="color: green;">// 64-bit 程序指针
    // VS2013 默认最大递归深度500，GCC4.8 默认最大递归深度900（-ftemplate-depth=n）
    </span><span style="color: black;">std::cout &lt;&lt; </span><span style="color: #2b91af;">someComputing</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, 500&gt;::retValume &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; </span><span style="color: green;">// 1+2+...+500
    </span><span style="color: #2b91af;">codeComputing</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">someComputing</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, 99&gt;&gt;::f();
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">8
125250
someComputing: i=99</span></pre>
<p>C++ 模板元编程<strong><span style="color: #ff0000;">概览框图</span></strong>如下（取自文献[9]）：</p>
<p><img style="display: inline;" title="C++ 模板元编程概览" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/131303579644843.png" alt="C++ 模板元编程概览" width="500" height="548"></p>
<p>下面我们将对图中的每个框进行深入讨论。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>3. 编译期数值计算</strong></span></p>
<p><strong><span style="color: #ff0000;">第一个 C++ 模板元程序</span></strong>是 Erwin Unruh 在 1994 年写的（文献[14]），这个程序计算小于给定数 N 的全部素数（又叫质数），程序并不运行（都不能通过编译），而是让编译器在错误信息中显示结果（直观展现了是编译期计算结果，C++ 模板元编程不是设计的功能，更像是在戏弄编译器，当然 C++11 有所改变），由于年代久远，原来的程序用现在的编译器已经不能编译了，下面的代码在原来程序基础上稍作了修改（GCC 4.8 下使用 -fpermissvie，只显示警告信息）：</p>
<pre class="code-cpp"><span style="color: green;">// Prime number computation by Erwin Unruh
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">struct </span><span style="color: #2b91af;">D </span><span style="color: black;">{ D(</span><span style="color: blue;">void</span><span style="color: black;">*); </span><span style="color: blue;">operator int</span><span style="color: black;">(); }; </span><span style="color: green;">// 构造函数参数为 void* 指针

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">p, </span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">struct </span><span style="color: #2b91af;">is_prime </span><span style="color: black;">{ </span><span style="color: green;">// 判断 p 是否为素数，即 p 不能整除 2...p-1
    </span><span style="color: blue;">enum </span><span style="color: black;">{ prim = (p%i) &amp;&amp; </span><span style="color: #2b91af;">is_prime</span><span style="color: black;">&lt;(i&gt;2?p:0), i-1&gt;::prim };
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt; </span><span style="color: blue;">struct </span><span style="color: #2b91af;">is_prime</span><span style="color: black;">&lt;0, 0&gt; { </span><span style="color: blue;">enum </span><span style="color: black;">{ </span><span style="color: #2f4f4f;">prim </span><span style="color: black;">= 1 }; };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt; </span><span style="color: blue;">struct </span><span style="color: #2b91af;">is_prime</span><span style="color: black;">&lt;0, 1&gt; { </span><span style="color: blue;">enum </span><span style="color: black;">{ </span><span style="color: #2f4f4f;">prim </span><span style="color: black;">= 1 }; };

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">struct </span><span style="color: #2b91af;">Prime_print </span><span style="color: black;">{
    </span><span style="color: #2b91af;">Prime_print</span><span style="color: black;">&lt;i-1&gt; a;
    </span><span style="color: blue;">enum </span><span style="color: black;">{ prim = </span><span style="color: #2b91af;">is_prime</span><span style="color: black;">&lt;i, i-1&gt;::prim };
    </span><span style="color: green;">// prim 为真时， prim?1:0 为 1，int 到 D&lt;i&gt; 转换报错；假时， 0 为 NULL 指针不报错
    </span><span style="color: blue;">void </span><span style="color: black;">f() { </span><span style="color: #2b91af;">D</span><span style="color: black;">&lt;i&gt; d = prim?1:0; a.f(); } </span><span style="color: green;">// 调用 a.f() 实例化 Prime_print&lt;i-1&gt;::f()
</span><span style="color: black;">};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt; </span><span style="color: blue;">struct </span><span style="color: #2b91af;">Prime_print</span><span style="color: black;">&lt;2&gt; { </span><span style="color: green;">// 特例，递归终止
    </span><span style="color: blue;">enum </span><span style="color: black;">{ </span><span style="color: #2f4f4f;">prim </span><span style="color: black;">= 1 };
    </span><span style="color: blue;">void </span><span style="color: black;">f() { </span><span style="color: #2b91af;">D</span><span style="color: black;">&lt;2&gt; d = </span><span style="color: #2f4f4f;">prim</span><span style="color: black;">?1:0; }
};

</span><span style="color: blue;">#ifndef </span><span style="color: black;">LAST
</span><span style="color: blue;">#define </span><span style="color: #6f008a;">LAST </span><span style="color: black;">10
</span><span style="color: blue;">#endif

int </span><span style="color: black;">main() {
    </span><span style="color: #2b91af;">Prime_print</span><span style="color: black;">&lt;</span><span style="color: #6f008a;">LAST</span><span style="color: black;">&gt; a; a.f(); </span><span style="color: green;">// 必须调用 a.f() 以实例化 Prime_print&lt;LAST&gt;::f()
</span><span style="color: black;">}</span></pre>
<pre class="console-cpp"><span style="color: black;">sh-4.2# g++ -std=c++11 -fpermissive -o main *.cpp
main.cpp: In member function 'void Prime_print&lt;2&gt;::f()':
main.cpp:17:33: warning: invalid conversion from 'int' to 'void*' [-fpermissive]
  void f() { D&lt;2&gt; d = prim ? 1 : 0; }
                                 ^
<strong>main.cpp:2:28: warning:   initializing argument 1 of 'D&lt;i&gt;::D(void*) [with int i = 2]' [-fpermissive]</strong>
 template&lt;int i&gt; struct D { D(void*); operator int(); };
                            ^
main.cpp: In instantiation of 'void Prime_print&lt;i&gt;::f() [with int i = 7]':
main.cpp:13:36:   recursively required from 'void Prime_print&lt;i&gt;::f() [with int i = 9]'
main.cpp:13:36:   required from 'void Prime_print&lt;i&gt;::f() [with int i = 10]'
main.cpp:25:27:   required from here
main.cpp:13:33: warning: invalid conversion from 'int' to 'void*' [-fpermissive]
  void f() { D&lt;i&gt; d = prim ? 1 : 0; a.f(); }
                                 ^
<strong>main.cpp:2:28: warning:   initializing argument 1 of 'D&lt;i&gt;::D(void*) [with int i = 7]' [-fpermissive]</strong>
 template&lt;int i&gt; struct D { D(void*); operator int(); };
                            ^
main.cpp: In instantiation of 'void Prime_print&lt;i&gt;::f() [with int i = 5]':
main.cpp:13:36:   recursively required from 'void Prime_print&lt;i&gt;::f() [with int i = 9]'
main.cpp:13:36:   required from 'void Prime_print&lt;i&gt;::f() [with int i = 10]'
main.cpp:25:27:   required from here
main.cpp:13:33: warning: invalid conversion from 'int' to 'void*' [-fpermissive]
  void f() { D&lt;i&gt; d = prim ? 1 : 0; a.f(); }
                                 ^
<strong>main.cpp:2:28: warning:   initializing argument 1 of 'D&lt;i&gt;::D(void*) [with int i = 5]' [-fpermissive]</strong>
 template&lt;int i&gt; struct D { D(void*); operator int(); };
                            ^
main.cpp: In instantiation of 'void Prime_print&lt;i&gt;::f() [with int i = 3]':
main.cpp:13:36:   recursively required from 'void Prime_print&lt;i&gt;::f() [with int i = 9]'
main.cpp:13:36:   required from 'void Prime_print&lt;i&gt;::f() [with int i = 10]'
main.cpp:25:27:   required from here
main.cpp:13:33: warning: invalid conversion from 'int' to 'void*' [-fpermissive]
  void f() { D&lt;i&gt; d = prim ? 1 : 0; a.f(); }
                                 ^
<strong>main.cpp:2:28: warning:   initializing argument 1 of 'D&lt;i&gt;::D(void*) [with int i = 3]' [-fpermissive]</strong>
 template&lt;int i&gt; struct D { D(void*); operator int(); };
                            ^</span></pre>
<p>上面的编译输出信息只给出了前一部分，虽然信息很杂，但还是可以看到其中有 10 以内全部素数：2、3、5、7（已经加粗显示关键行）。</p>
<p>到目前为止，虽然已经看到了阶乘、求和等递归数值计算，但都没涉及原理，下面以求和为例讲解 C++ 模板编译期数值计算的原理：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">N&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">sumt</span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static const int </span><span style="color: black;">ret = </span><span style="color: #2b91af;">sumt</span><span style="color: black;">&lt;N-1&gt;::ret + N;
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">sumt</span><span style="color: black;">&lt;0&gt;{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static const int </span><span style="color: black;">ret = 0;
};

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    std::cout &lt;&lt; </span><span style="color: #2b91af;">sumt</span><span style="color: black;">&lt;5&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">15</span></pre>
<p>当编译器遇到 sumt&lt;5&gt; 时，试图实例化之，sumt&lt;5&gt; 引用了 sumt&lt;5-1&gt; 即 sumt&lt;4&gt;，试图实例化 sumt&lt;4&gt;，以此类推，直到 sumt&lt;0&gt;，sumt&lt;0&gt; 匹配模板特例，sumt&lt;0&gt;::ret 为 0，sumt&lt;1&gt;::ret 为 sumt&lt;0&gt;::ret+1 为 1，以此类推，sumt&lt;5&gt;::ret 为 15。值得一提的是，虽然对用户来说程序只是输出了一个编译期常量 sumt&lt;5&gt;::ret，但在背后，编译器其实至少处理了 sumt&lt;0&gt; 到 sumt&lt;5&gt; 共 6 个类型。</p>
<p>从这个例子我们也可以窥探 C++ 模板元编程的函数式编程范型，对比结构化求和程序：for(i=0,sum=0; i&lt;=N; ++i) sum+=i; 用逐步改变存储（即变量 sum）的方式来对计算过程进行编程，模板元程序没有可变的存储（都是编译期常量，是不可变的变量），要表达求和过程就要用很多个常量：sumt&lt;0&gt;::ret，sumt&lt;1&gt;::ret，...，sumt&lt;5&gt;::ret 。函数式编程看上去似乎效率低下（因为它和数学接近，而不是和硬件工作方式接近），但有自己的优势：描述问题更加简洁清晰（前提是熟悉这种方式），没有可变的变量就没有数据依赖，方便进行并行化。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>4. 模板下的控制结构</strong></span></p>
<p>模板实现的条件 <strong><span style="color: #ff0000;">if 和 while 语句</span></strong>如下（文献[9]）：</p>
<pre class="code-cpp"><span style="color: green;">// 通例为空，若不匹配特例将报错，很好的调试手段（这里是 bool 就无所谓了）
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">bool </span><span style="color: black;">c, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">IF_ </span><span style="color: black;">{ };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">true</span><span style="color: black;">, </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">Then reType</span><span style="color: black;">; };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">false</span><span style="color: black;">,</span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">Else reType</span><span style="color: black;">; };

</span><span style="color: green;">// 隐含要求： Condition 返回值 ret，Statement 有类型 Next
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">Condition</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Statement</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">WHILE_ </span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">Statement</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">STOP </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">Statement reType</span><span style="color: black;">; };
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef typename
        </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Condition</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Statement</span><span style="color: black;">&gt;::ret,
        </span><span style="color: #2b91af;">WHILE_</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Condition</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Statement</span><span style="color: black;">::</span><span style="color: #2b91af;">Next</span><span style="color: black;">&gt;,
        </span><span style="color: #2b91af;">STOP</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Statement</span><span style="color: black;">&gt;&gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">::</span><span style="color: #2b91af;">reType
    reType</span><span style="color: black;">;
};</span></pre>
<p>IF_&lt;&gt; 的使用示例见下面：</p>
<pre class="code-cpp"><span style="color: blue;">const int </span><span style="color: black;">len = 4;
</span><span style="color: blue;">typedef
    </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: blue;">short</span><span style="color: black;">)==len, </span><span style="color: blue;">short</span><span style="color: black;">,
    </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: blue;">int</span><span style="color: black;">)==len, </span><span style="color: blue;">int</span><span style="color: black;">,
    </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: blue;">long</span><span style="color: black;">)==len, </span><span style="color: blue;">long</span><span style="color: black;">,
    </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: blue;">long long</span><span style="color: black;">)==len, </span><span style="color: blue;">long long</span><span style="color: black;">,
    </span><span style="color: blue;">void</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">reType
int_my</span><span style="color: black;">; </span><span style="color: green;">// 定义一个指定字节数的类型
</span><span style="color: black;">std::cout &lt;&lt; </span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: #2b91af;">int_my</span><span style="color: black;">) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;</span></pre>
<pre class="console-cpp"><span style="color: black;">4</span></pre>
<p>WHILE_&lt;&gt; 的使用示例见下面：</p>
<pre class="code-cpp"><span style="color: green;">// 计算 1^e+2^e+...+n^e
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n, </span><span style="color: blue;">int </span><span style="color: black;">e&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">sum_pow </span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">e&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">pow_e</span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret=i*</span><span style="color: #2b91af;">pow_e</span><span style="color: black;">&lt;i,e-1&gt;::ret }; };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">pow_e</span><span style="color: black;">&lt;i,0&gt;{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret=1 }; };
    </span><span style="color: green;">// 计算 i^e，嵌套类使得能够定义嵌套模板元函数，private 访问控制隐藏实现细节
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">pow</span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret=</span><span style="color: #2b91af;">pow_e</span><span style="color: black;">&lt;i,e&gt;::ret }; };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">stat</span><span style="color: black;">&gt;
    </span><span style="color: blue;">class </span><span style="color: #2b91af;">cond </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret=(</span><span style="color: #2b91af;">stat</span><span style="color: black;">::ri&lt;=n) }; };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">sum&gt;
    </span><span style="color: blue;">class </span><span style="color: #2b91af;">stat </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">stat</span><span style="color: black;">&lt;i+1, sum+</span><span style="color: #2b91af;">pow</span><span style="color: black;">&lt;i&gt;::ret&gt; </span><span style="color: #2b91af;">Next</span><span style="color: black;">;
                         </span><span style="color: blue;">enum</span><span style="color: black;">{ ri=i, ret=sum }; };
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">enum</span><span style="color: black;">{ ret = </span><span style="color: #2b91af;">WHILE_</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">cond</span><span style="color: black;">, </span><span style="color: #2b91af;">stat</span><span style="color: black;">&lt;1,0&gt;&gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">::ret };
};

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    std::cout &lt;&lt; </span><span style="color: #2b91af;">sum_pow</span><span style="color: black;">&lt;10, 2&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">385</span></pre>
<p>为了展现编译期数值计算的强大能力，下面是一个更复杂的计算：最大公约数（Greatest Common Divisor，GCD）和最小公倍数（Lowest Common Multiple，LCM），经典的辗转相除算法：</p>
<pre class="code-cpp"><span style="color: green;">// 最小公倍数，普通函数
</span><span style="color: blue;">int </span><span style="color: black;">lcm(</span><span style="color: blue;">int </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: gray;">b</span><span style="color: black;">){
    </span><span style="color: blue;">int </span><span style="color: black;">r, lcm=</span><span style="color: gray;">a</span><span style="color: black;">*</span><span style="color: gray;">b</span><span style="color: black;">;
    </span><span style="color: blue;">while</span><span style="color: black;">(r=</span><span style="color: gray;">a</span><span style="color: black;">%</span><span style="color: gray;">b</span><span style="color: black;">) { </span><span style="color: gray;">a </span><span style="color: black;">= </span><span style="color: gray;">b</span><span style="color: black;">; </span><span style="color: gray;">b </span><span style="color: black;">= r; } </span><span style="color: green;">// 因为用可变的存储，不能写成 a=b; b=a%b;
    </span><span style="color: blue;">return </span><span style="color: black;">lcm/</span><span style="color: gray;">b</span><span style="color: black;">;
}
</span><span style="color: green;">// 递归函数版本
</span><span style="color: blue;">int </span><span style="color: black;">gcd_r(</span><span style="color: blue;">int </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: gray;">b</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: gray;">b</span><span style="color: black;">==0 ? </span><span style="color: gray;">a </span><span style="color: black;">: gcd_r(</span><span style="color: gray;">b</span><span style="color: black;">, </span><span style="color: gray;">a</span><span style="color: black;">%</span><span style="color: gray;">b</span><span style="color: black;">); } </span><span style="color: green;">// 简洁
</span><span style="color: blue;">int </span><span style="color: black;">lcm_r(</span><span style="color: blue;">int </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: gray;">b</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: gray;">a </span><span style="color: black;">* </span><span style="color: gray;">b </span><span style="color: black;">/ gcd_r(</span><span style="color: gray;">a</span><span style="color: black;">,</span><span style="color: gray;">b</span><span style="color: black;">); }

</span><span style="color: green;">// 模板版本
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">a, </span><span style="color: blue;">int </span><span style="color: black;">b&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">lcm_T</span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">stat</span><span style="color: black;">&gt;
    </span><span style="color: blue;">class </span><span style="color: #2b91af;">cond </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret=(</span><span style="color: #2b91af;">stat</span><span style="color: black;">::div!=0) }; };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">a, </span><span style="color: blue;">int </span><span style="color: black;">b&gt;
    </span><span style="color: blue;">class </span><span style="color: #2b91af;">stat </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">stat</span><span style="color: black;">&lt;b, a%b&gt; </span><span style="color: #2b91af;">Next</span><span style="color: black;">; </span><span style="color: blue;">enum</span><span style="color: black;">{ div=a%b, ret=b }; };
    </span><span style="color: blue;">static const int </span><span style="color: black;">gcd = </span><span style="color: #2b91af;">WHILE_</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">cond</span><span style="color: black;">, </span><span style="color: #2b91af;">stat</span><span style="color: black;">&lt;a,b&gt;&gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">::ret;
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static const int </span><span style="color: black;">ret = a * b / gcd;
};
</span><span style="color: green;">// 递归模板版本
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">a, </span><span style="color: blue;">int </span><span style="color: black;">b&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">lcm_T_r</span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">a, </span><span style="color: blue;">int </span><span style="color: black;">b&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">gcd </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret = </span><span style="color: #2b91af;">gcd</span><span style="color: black;">&lt;b,a%b&gt;::ret }; };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">a&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">gcd</span><span style="color: black;">&lt;a, 0&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum</span><span style="color: black;">{ ret = a }; };
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static const int </span><span style="color: black;">ret = a * b / </span><span style="color: #2b91af;">gcd</span><span style="color: black;">&lt;a,b&gt;::ret;
};

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    std::cout &lt;&lt; lcm(100, 36) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; lcm_r(100, 36) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">lcm_T</span><span style="color: black;">&lt;100, 36&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">lcm_T_r</span><span style="color: black;">&lt;100, 36&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">900
900
900
900</span></pre>
<p>上面例子中，定义一个类的整型常量，可以用 enum，也可以用 static const int，需要注意的是 enum 定义的常量的字节数不会超过 sizeof(int) （文献[2]）。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>5. 循环展开</strong></span></p>
<p>文献[11]展示了一个<span style="color: #ff0000;"><strong>循环展开</strong></span>（loop unrolling）的例子 -- 冒泡排序：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;utility&gt;  </span><span style="color: green;">// std::swap

// dynamic code, 普通函数版本
</span><span style="color: blue;">void </span><span style="color: black;">bubbleSort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: gray;">n</span><span style="color: black;">)
{
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i=</span><span style="color: gray;">n</span><span style="color: black;">-1; i&gt;0; --i) {
        </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">j=0; j&lt;i; ++j)
            </span><span style="color: blue;">if </span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[j]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j+1]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[j], </span><span style="color: gray;">data</span><span style="color: black;">[j+1]);
    }
}
</span><span style="color: green;">// 数据长度为 4 时，手动循环展开
</span><span style="color: blue;">inline void </span><span style="color: black;">bubbleSort4(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">)
{
</span><span style="color: blue;">#define </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(i, j) </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[i]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[i], </span><span style="color: gray;">data</span><span style="color: black;">[j])
    </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(0, 1); </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(1, 2); </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(2, 3);
    </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(0, 1); </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(1, 2);
    </span><span style="color: #6f008a;">COMP_SWAP</span><span style="color: black;">(0, 1);
}

</span><span style="color: green;">// 递归函数版本，指导模板思路，最后一个参数是哑参数（dummy parameter），仅为分辨重载函数
</span><span style="color: blue;">class </span><span style="color: #2b91af;">recursion </span><span style="color: black;">{ };
</span><span style="color: blue;">void </span><span style="color: black;">bubbleSort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: gray;">n</span><span style="color: black;">, </span><span style="color: #2b91af;">recursion</span><span style="color: black;">)
{
    </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">n</span><span style="color: black;">&lt;=1) </span><span style="color: blue;">return</span><span style="color: black;">;
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">j=0; j&lt;</span><span style="color: gray;">n</span><span style="color: black;">-1; ++j) </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[j]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j+1]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[j], </span><span style="color: gray;">data</span><span style="color: black;">[j+1]);
    bubbleSort(</span><span style="color: gray;">data</span><span style="color: black;">, </span><span style="color: gray;">n</span><span style="color: black;">-1, </span><span style="color: #2b91af;">recursion</span><span style="color: black;">());
}

</span><span style="color: green;">// static code, 模板元编程版本
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">inline void </span><span style="color: black;">IntSwap(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { </span><span style="color: green;">// 比较和交换两个相邻元素
    </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[i]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[i], </span><span style="color: gray;">data</span><span style="color: black;">[j]);
}

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">inline void </span><span style="color: black;">IntBubbleSortLoop(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { </span><span style="color: green;">// 一次冒泡，将前 i 个元素中最大的置换到最后
    </span><span style="color: black;">IntSwap&lt;j, j+1&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
    IntBubbleSortLoop&lt;j&lt;i-1?i:0, j&lt;i-1?(j+1):0&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
}
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">inline void </span><span style="color: black;">IntBubbleSortLoop&lt;0, 0&gt;(</span><span style="color: blue;">int</span><span style="color: black;">*) { }

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt;
</span><span style="color: blue;">inline void </span><span style="color: black;">IntBubbleSort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { </span><span style="color: green;">// 模板冒泡排序循环展开
    </span><span style="color: black;">IntBubbleSortLoop&lt;n-1, 0&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
    IntBubbleSort&lt;n-1&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
}
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">inline void </span><span style="color: black;">IntBubbleSort&lt;1&gt;(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { }</span></pre>
<p>对循环次数固定且比较小的循环语句，对其进行展开并内联可以避免函数调用以及执行循环语句中的分支，从而可以提高性能，对上述代码做如下测试，代码在 VS2013 的 Release 下编译运行：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;omp.h&gt;
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;string.h&gt; </span><span style="color: green;">// memcpy

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: blue;">double </span><span style="color: black;">t1, t2, t3; </span><span style="color: blue;">const int </span><span style="color: black;">num=100000000;
    </span><span style="color: blue;">int </span><span style="color: black;">data[4]; </span><span style="color: blue;">int </span><span style="color: black;">inidata[4]={3,4,2,1};
    t1 = omp_get_wtime();
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i=0; i&lt;num; ++i) { memcpy(data, inidata, 4); bubbleSort(data, 4); }
    t1 = omp_get_wtime()-t1;
    t2 = omp_get_wtime();
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i=0; i&lt;num; ++i) { memcpy(data, inidata, 4); bubbleSort4(data); }
    t2 = omp_get_wtime()-t2;
    t3 = omp_get_wtime();
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i=0; i&lt;num; ++i) { memcpy(data, inidata, 4); IntBubbleSort&lt;4&gt;(data); }
    t3 = omp_get_wtime()-t3;
    std::cout &lt;&lt; t1/t3 &lt;&lt; </span><span style="color: #a31515;">'\t' </span><span style="color: black;">&lt;&lt; t2/t3 &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">2.38643 0.926521</span></pre>
<p>上述结果表明，模板元编程实现的循环展开能够达到和手动循环展开相近的性能（90% 以上），并且性能是循环版本的 2 倍多（如果扣除 memcpy 函数占据的部分加速比将更高，根据 Amdahl 定律）。这里可能有人会想，既然循环次数固定，为什么不直接手动循环展开呢，难道就为了使用模板吗？当然不是，有时候循环次数确实是编译期固定值，但对用户并不是固定的，比如要实现数学上向量计算的类，因为可能是 2、3、4 维，所以写成模板，把维度作为 int 型模板参数，这时因为不知道具体是几维的也就不得不用循环，不过因为维度信息在模板实例化时是编译期常量且较小，所以编译器很可能在代码优化时进行循环展开，但我们想让这一切发生的更可控一些。</p>
<p>上面用三个函数模板 IntSwap&lt;&gt;()、 IntBubbleSortLoop&lt;&gt;()、 IntBubbleSort&lt;&gt;() 来实现一个排序功能，不但显得分散（和封装原理不符），还暴露了实现细节，我们可以仿照上一节的代码，将 IntBubbleSortLoop&lt;&gt;()、 IntBubbleSort&lt;&gt;() 嵌入其他模板内部，因为函数不允许嵌套，我们只能用类模板：</p>
<pre class="code-cpp"><span style="color: green;">// 整合成一个类模板实现，看着好，但引入了 代码膨胀
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSortC </span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
    </span><span style="color: blue;">static inline void </span><span style="color: black;">IntSwap(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { </span><span style="color: green;">// 比较和交换两个相邻元素
        </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[i]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[i], </span><span style="color: gray;">data</span><span style="color: black;">[j]);
    }
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
    </span><span style="color: blue;">static inline void </span><span style="color: black;">IntBubbleSortLoop(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { </span><span style="color: green;">// 一次冒泡
        </span><span style="color: black;">IntSwap&lt;j, j+1&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
        IntBubbleSortLoop&lt;j&lt;i-1?i:0, j&lt;i-1?(j+1):0&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
    }
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
    </span><span style="color: blue;">static inline void </span><span style="color: black;">IntBubbleSortLoop&lt;0, 0&gt;(</span><span style="color: blue;">int</span><span style="color: black;">*) { }
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static inline void </span><span style="color: black;">sort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
        IntBubbleSortLoop&lt;n-1, 0&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
        </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;n-1&gt;::sort(</span><span style="color: gray;">data</span><span style="color: black;">);
    }
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;0&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static inline void </span><span style="color: black;">sort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { }
};

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: blue;">int </span><span style="color: black;">data[4] = {3,4,2,1};
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;4&gt;::sort(data); </span><span style="color: green;">// 如此调用
    </span><span style="color: black;">std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<p>上面代码看似很好，不仅整合了代码，借助类成员的访问控制，还隐藏了实现细节。不过它存在着很大问题，如果实例化 IntBubbleSortC&lt;4&gt;、 IntBubbleSortC&lt;3&gt;、 IntBubbleSortC&lt;2&gt;，将实例化成员函数 IntBubbleSortC&lt;4&gt;::IntSwap&lt;0, 1&gt;()、 IntBubbleSortC&lt;4&gt;::IntSwap&lt;1, 2&gt;()、 IntBubbleSortC&lt;4&gt;::IntSwap&lt;2, 3&gt;()、 IntBubbleSortC&lt;3&gt;::IntSwap&lt;0, 1&gt;()、 IntBubbleSortC&lt;3&gt;::IntSwap&lt;1, 2&gt;()、 IntBubbleSortC&lt;2&gt;::IntSwap&lt;0, 1&gt;()，而在原来的看着分散的代码中 IntSwap&lt;0, 1&gt;() 只有一个。这将导致<span style="color: #ff0000;"><strong>代码膨胀</strong></span>（code bloat），即生成的可执行文件体积变大（代码膨胀另一含义是源代码增大，见文献[1]第11章）。不过这里使用了内联（inline），如果编译器确实内联展开代码则不会导致代码膨胀（除了循环展开本身会带来的代码膨胀），但因为重复编译原本可以复用的模板实例，会增加编译时间。在上一节的例子中，因为只涉及编译期常量计算，并不涉及函数（函数模板，或类模板的成员函数，函数被编译成具体的机器二进制代码），并不会出现代码膨胀。</p>
<p>为了清晰证明上面的论述，我们去掉所有 inline 并将函数实现放到类外面（类里面实现的成员函数都是内联的，因为函数实现可能被包含多次，见文献[2] 10.2.9，不过现在的编译器优化能力很强，很多时候加不加 inline 并不影响编译器自己对内联的选择...），分别编译分散版本和类模板封装版本的冒泡排序代码编译生成的目标文件（VS2013 下是 .obj 文件）的大小，代码均在 VS2013 Debug 模式下编译（防止编译器优化），比较 main.obj （源文件是 main.cpp）大小。</p>
<p>类模板封装版本代码如下，注意将成员函数在外面定义的写法：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;utility&gt;  </span><span style="color: green;">// std::swap

// 整合成一个类模板实现，看着好，但引入了 代码膨胀
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSortC </span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt; </span><span style="color: blue;">static void </span><span style="color: black;">IntSwap(</span><span style="color: blue;">int</span><span style="color: black;">* data);
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt; </span><span style="color: blue;">static void </span><span style="color: black;">IntBubbleSortLoop(</span><span style="color: blue;">int</span><span style="color: black;">* data);
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt; </span><span style="color: blue;">static void </span><span style="color: black;">IntBubbleSortLoop&lt;0, 0&gt;(</span><span style="color: blue;">int</span><span style="color: black;">*) { }
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static void </span><span style="color: black;">sort(</span><span style="color: blue;">int</span><span style="color: black;">* data);
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;0&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static void </span><span style="color: black;">sort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { }
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt; </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">void </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;n&gt;::IntSwap(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
    </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[i]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[i], </span><span style="color: gray;">data</span><span style="color: black;">[j]);
}
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt; </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">void </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;n&gt;::IntBubbleSortLoop(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
    IntSwap&lt;j, j+1&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
    IntBubbleSortLoop&lt;j&lt;i-1?i:0, j&lt;i-1?(j+1):0&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
}
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt;
</span><span style="color: blue;">void </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;n&gt;::sort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
    IntBubbleSortLoop&lt;n-1, 0&gt;(</span><span style="color: gray;">data</span><span style="color: black;">);
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;n-1&gt;::sort(</span><span style="color: gray;">data</span><span style="color: black;">);
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: blue;">int </span><span style="color: black;">data[40] = {3,4,2,1};
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;2&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;3&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;4&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;5&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;6&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;7&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;8&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;9&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;10&gt;::sort(data); </span><span style="color: #2b91af;">IntBubbleSortC</span><span style="color: black;">&lt;11&gt;::sort(data);
</span><span style="color: blue;">#if </span><span style="color: black;">0</span><span style="color: gray;">
    IntBubbleSortC&lt;12&gt;::sort(data); IntBubbleSortC&lt;13&gt;::sort(data);
    IntBubbleSortC&lt;14&gt;::sort(data); IntBubbleSortC&lt;15&gt;::sort(data);
    IntBubbleSortC&lt;16&gt;::sort(data); IntBubbleSortC&lt;17&gt;::sort(data);
    IntBubbleSortC&lt;18&gt;::sort(data); IntBubbleSortC&lt;19&gt;::sort(data);
    IntBubbleSortC&lt;20&gt;::sort(data); IntBubbleSortC&lt;21&gt;::sort(data);

    IntBubbleSortC&lt;22&gt;::sort(data); IntBubbleSortC&lt;23&gt;::sort(data);
    IntBubbleSortC&lt;24&gt;::sort(data); IntBubbleSortC&lt;25&gt;::sort(data);
    IntBubbleSortC&lt;26&gt;::sort(data); IntBubbleSortC&lt;27&gt;::sort(data);
    IntBubbleSortC&lt;28&gt;::sort(data); IntBubbleSortC&lt;29&gt;::sort(data);
    IntBubbleSortC&lt;30&gt;::sort(data); IntBubbleSortC&lt;31&gt;::sort(data);
</span><span style="color: blue;">#endif
    </span><span style="color: black;">std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<p>分散定义函数模板版本代码如下，为了更具可比性，也将函数放在类里面作为成员函数：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;utility&gt;  </span><span style="color: green;">// std::swap

// static code, 模板元编程版本
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntSwap </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static void </span><span style="color: black;">swap(</span><span style="color: blue;">int</span><span style="color: black;">* data);
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSortLoop </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static void </span><span style="color: black;">loop(</span><span style="color: blue;">int</span><span style="color: black;">* data);
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSortLoop</span><span style="color: black;">&lt;0, 0&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static void </span><span style="color: black;">loop(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { }
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSort </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static void </span><span style="color: black;">sort(</span><span style="color: blue;">int</span><span style="color: black;">* data);
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;0&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static void </span><span style="color: black;">sort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) { }
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">void </span><span style="color: #2b91af;">IntSwap</span><span style="color: black;">&lt;i, j&gt;::swap(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
    </span><span style="color: blue;">if</span><span style="color: black;">(</span><span style="color: gray;">data</span><span style="color: black;">[i]&gt;</span><span style="color: gray;">data</span><span style="color: black;">[j]) std::swap(</span><span style="color: gray;">data</span><span style="color: black;">[i], </span><span style="color: gray;">data</span><span style="color: black;">[j]);
}
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i, </span><span style="color: blue;">int </span><span style="color: black;">j&gt;
</span><span style="color: blue;">void </span><span style="color: #2b91af;">IntBubbleSortLoop</span><span style="color: black;">&lt;i, j&gt;::loop(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
    </span><span style="color: #2b91af;">IntSwap</span><span style="color: black;">&lt;j, j+1&gt;::swap(</span><span style="color: gray;">data</span><span style="color: black;">);
    </span><span style="color: #2b91af;">IntBubbleSortLoop</span><span style="color: black;">&lt;j&lt;i-1?i:0, j&lt;i-1?(j+1):0&gt;::loop(</span><span style="color: gray;">data</span><span style="color: black;">);
}
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">n&gt;
</span><span style="color: blue;">void </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;n&gt;::sort(</span><span style="color: blue;">int</span><span style="color: black;">* </span><span style="color: gray;">data</span><span style="color: black;">) {
    </span><span style="color: #2b91af;">IntBubbleSortLoop</span><span style="color: black;">&lt;n-1, 0&gt;::loop(</span><span style="color: gray;">data</span><span style="color: black;">);
    </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;n-1&gt;::sort(</span><span style="color: gray;">data</span><span style="color: black;">);
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: blue;">int </span><span style="color: black;">data[40] = {3,4,2,1};
    </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;2&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;3&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;4&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;5&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;6&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;7&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;8&gt;::sort(data);  </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;9&gt;::sort(data);
    </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;10&gt;::sort(data); </span><span style="color: #2b91af;">IntBubbleSort</span><span style="color: black;">&lt;11&gt;::sort(data);
</span><span style="color: blue;">#if </span><span style="color: black;">0</span><span style="color: gray;">
    IntBubbleSort&lt;12&gt;::sort(data); IntBubbleSort&lt;13&gt;::sort(data);
    IntBubbleSort&lt;14&gt;::sort(data); IntBubbleSort&lt;15&gt;::sort(data);
    IntBubbleSort&lt;16&gt;::sort(data); IntBubbleSort&lt;17&gt;::sort(data);
    IntBubbleSort&lt;18&gt;::sort(data); IntBubbleSort&lt;19&gt;::sort(data);
    IntBubbleSort&lt;20&gt;::sort(data); IntBubbleSort&lt;21&gt;::sort(data);

    IntBubbleSort&lt;22&gt;::sort(data); IntBubbleSort&lt;23&gt;::sort(data);
    IntBubbleSort&lt;24&gt;::sort(data); IntBubbleSort&lt;25&gt;::sort(data);
    IntBubbleSort&lt;26&gt;::sort(data); IntBubbleSort&lt;27&gt;::sort(data);
    IntBubbleSort&lt;28&gt;::sort(data); IntBubbleSort&lt;29&gt;::sort(data);
    IntBubbleSort&lt;30&gt;::sort(data); IntBubbleSort&lt;31&gt;::sort(data);
</span><span style="color: blue;">#endif
    </span><span style="color: black;">std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<p>程序中条件编译都未打开时（#if 0），main.obj 大小分别为 264 KB 和 211 KB，条件编译打开时（#if 1），main.obj 大小分别为 1073 KB 和 620 KB。可以看到，类模板封装版的对象文件不但绝对大小更大，而且增长更快，这和之前分析是一致的。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>6. 表达式模板，向量运算</strong></span></p>
<p>文献[12]展示了一个<span style="color: #ff0000;"><strong>表达式模板</strong></span>（Expression Templates）的例子：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt; </span><span style="color: green;">// std::cout
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;cmath&gt;    </span><span style="color: green;">// std::sqrt()

// 表达式类型
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DExprLiteral </span><span style="color: black;">{                    </span><span style="color: green;">// 文字量
    </span><span style="color: blue;">double </span><span style="color: black;">a_;
</span><span style="color: blue;">public</span><span style="color: black;">:
    DExprLiteral(</span><span style="color: blue;">double </span><span style="color: gray;">a</span><span style="color: black;">) : a_(</span><span style="color: gray;">a</span><span style="color: black;">) { }
    </span><span style="color: blue;">double </span><span style="color: black;">operator()(</span><span style="color: blue;">double </span><span style="color: gray;">x</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: black;">a_; }
};
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DExprIdentity </span><span style="color: black;">{                   </span><span style="color: green;">// 自变量
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">double </span><span style="color: black;">operator()(</span><span style="color: blue;">double </span><span style="color: gray;">x</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: gray;">x</span><span style="color: black;">; }
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">, </span><span style="color: blue;">class </span><span style="color: #2b91af;">B</span><span style="color: black;">, </span><span style="color: blue;">class </span><span style="color: #2b91af;">Op</span><span style="color: black;">&gt;    </span><span style="color: green;">// 双目操作
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DBinExprOp </span><span style="color: black;">{
    </span><span style="color: #2b91af;">A </span><span style="color: black;">a_; </span><span style="color: #2b91af;">B </span><span style="color: black;">b_;
</span><span style="color: blue;">public</span><span style="color: black;">:
    DBinExprOp(</span><span style="color: blue;">const </span><span style="color: #2b91af;">A</span><span style="color: black;">&amp; </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">const </span><span style="color: #2b91af;">B</span><span style="color: black;">&amp; </span><span style="color: gray;">b</span><span style="color: black;">) : a_(</span><span style="color: gray;">a</span><span style="color: black;">), b_(</span><span style="color: gray;">b</span><span style="color: black;">) { }
    </span><span style="color: blue;">double </span><span style="color: black;">operator()(</span><span style="color: blue;">double </span><span style="color: gray;">x</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: #2b91af;">Op</span><span style="color: black;">::apply(a_(</span><span style="color: gray;">x</span><span style="color: black;">), b_(</span><span style="color: gray;">x</span><span style="color: black;">)); }
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">, </span><span style="color: blue;">class </span><span style="color: #2b91af;">Op</span><span style="color: black;">&gt;             </span><span style="color: green;">// 单目操作
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DUnaryExprOp </span><span style="color: black;">{
    </span><span style="color: #2b91af;">A </span><span style="color: black;">a_;
</span><span style="color: blue;">public</span><span style="color: black;">:
    DUnaryExprOp(</span><span style="color: blue;">const </span><span style="color: #2b91af;">A</span><span style="color: black;">&amp; </span><span style="color: gray;">a</span><span style="color: black;">) : a_(</span><span style="color: gray;">a</span><span style="color: black;">) { }
    </span><span style="color: blue;">double </span><span style="color: black;">operator()(</span><span style="color: blue;">double </span><span style="color: gray;">x</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: #2b91af;">Op</span><span style="color: black;">::apply(a_(</span><span style="color: gray;">x</span><span style="color: black;">)); }
};
</span><span style="color: green;">// 表达式
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DExpr </span><span style="color: black;">{
    </span><span style="color: #2b91af;">A </span><span style="color: black;">a_;
</span><span style="color: blue;">public</span><span style="color: black;">:
    DExpr() { }
    DExpr(</span><span style="color: blue;">const </span><span style="color: #2b91af;">A</span><span style="color: black;">&amp; </span><span style="color: gray;">a</span><span style="color: black;">) : a_(</span><span style="color: gray;">a</span><span style="color: black;">) { }
    </span><span style="color: blue;">double </span><span style="color: black;">operator()(</span><span style="color: blue;">double </span><span style="color: gray;">x</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: black;">a_(</span><span style="color: gray;">x</span><span style="color: black;">); }
};

</span><span style="color: green;">// 运算符，模板参数 A、B 为参与运算的表达式类型
// operator /, division
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DApDiv </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static double </span><span style="color: black;">apply(</span><span style="color: blue;">double </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">b</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: gray;">a </span><span style="color: black;">/ </span><span style="color: gray;">b</span><span style="color: black;">; } };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">, </span><span style="color: blue;">class </span><span style="color: #2b91af;">B</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DBinExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">B</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApDiv</span><span style="color: black;">&gt; &gt;
operator/(</span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">B</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">b</span><span style="color: black;">) {
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">DBinExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">B</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApDiv</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">ExprT</span><span style="color: black;">;
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">(</span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: gray;">b</span><span style="color: black;">));
}
</span><span style="color: green;">// operator +, addition
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DApAdd </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static double </span><span style="color: black;">apply(</span><span style="color: blue;">double </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">b</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: gray;">a </span><span style="color: black;">+ </span><span style="color: gray;">b</span><span style="color: black;">; } };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">, </span><span style="color: blue;">class </span><span style="color: #2b91af;">B</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DBinExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">B</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApAdd</span><span style="color: black;">&gt; &gt;
operator+(</span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">B</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">b</span><span style="color: black;">) {
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">DBinExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">B</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApAdd</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">ExprT</span><span style="color: black;">;
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">(</span><span style="color: gray;">a</span><span style="color: black;">, </span><span style="color: gray;">b</span><span style="color: black;">));
}
</span><span style="color: green;">// sqrt(), square rooting
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DApSqrt </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static double </span><span style="color: black;">apply(</span><span style="color: blue;">double </span><span style="color: gray;">a</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: black;">std::sqrt(</span><span style="color: gray;">a</span><span style="color: black;">); } };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DUnaryExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApSqrt</span><span style="color: black;">&gt; &gt;
sqrt(</span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">a</span><span style="color: black;">) {
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">DUnaryExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApSqrt</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">ExprT</span><span style="color: black;">;
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">(</span><span style="color: gray;">a</span><span style="color: black;">));
}
</span><span style="color: green;">// operator-, negative sign
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DApNeg </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static double </span><span style="color: black;">apply(</span><span style="color: blue;">double </span><span style="color: gray;">a</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: black;">-</span><span style="color: gray;">a</span><span style="color: black;">; } };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DUnaryExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApNeg</span><span style="color: black;">&gt; &gt;
operator-(</span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">a</span><span style="color: black;">) {
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">DUnaryExprOp</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;, </span><span style="color: #2b91af;">DApNeg</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">ExprT</span><span style="color: black;">;
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">&gt;(</span><span style="color: #2b91af;">ExprT</span><span style="color: black;">(</span><span style="color: gray;">a</span><span style="color: black;">));
}

</span><span style="color: green;">// evaluate()
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">Expr</span><span style="color: black;">&gt;
</span><span style="color: blue;">void </span><span style="color: black;">evaluate(</span><span style="color: blue;">const </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Expr</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">expr</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">start</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">end</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">step</span><span style="color: black;">) {
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">double </span><span style="color: black;">i=</span><span style="color: gray;">start</span><span style="color: black;">; i&lt;</span><span style="color: gray;">end</span><span style="color: black;">; i+=</span><span style="color: gray;">step</span><span style="color: black;">) std::cout &lt;&lt; </span><span style="color: gray;">expr</span><span style="color: black;">(i) &lt;&lt; </span><span style="color: #a31515;">' '</span><span style="color: black;">;
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExprIdentity</span><span style="color: black;">&gt; x;
    evaluate( -x / sqrt( </span><span style="color: #2b91af;">DExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">DExprLiteral</span><span style="color: black;">&gt;(1.0) + x ) , 0.0, 10.0, 1.0);
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">-0 -0.707107 -1.1547 -1.5 -1.78885 -2.04124 -2.26779 -2.47487 -2.66667 -2.84605</span></pre>
<p>代码有点长（我已经尽量压缩行数），请先看最下面的 main() 函数，表达式模板允许我们以 “-x / sqrt( 1.0 + x )” 这种类似数学表达式的方式传参数，在 evaluate() 内部，将 0-10 的数依次赋给自变量 x 对表达式进行求值，这是通过在 template&lt;&gt; DExpr 类模板内部重载 operator() 实现的。我们来看看这一切是如何发生的。</p>
<p>在 main() 中调用 evaluate() 时，编译器根据全局重载的加号、sqrt、除号、负号推断“-x / sqrt( 1.0 + x )” 的类型是 Dexpr&lt;DBinExprOp&lt;Dexpr&lt;DUnaryExprOp&lt;Dexpr&lt;DExprIdentity&gt;, DApNeg&gt;&gt;, Dexpr&lt;DUnaryExprOp&lt;Dexpr&lt;DBinExprOp&lt;Dexpr&lt;DExprLiteral&gt;, Dexpr&lt;DExprIdentity&gt;, DApAdd&gt;&gt;, DApSqrt&gt;&gt;, DApDiv&gt;&gt;（即将每个表达式编码到一种类型，设这个类型为 ultimateExprType），并用此类型实例化函数模板 evaluate()，类型的推导见下图。在 evaluate() 中，对表达式进行求值 expr(i)，调用 ultimateExprType 的 operator()，这引起一系列的 operator() 和 Op::apply() 的调用，最终遇到基础类型 “表达式类型” DExprLiteral 和 DExprIdentity，这个过程见下图。总结就是，请看下图，从下到上类型推断，从上到下 operator() 表达式求值。</p>
<p><img style="display: inline;" title="表达式模板，Expression Templates" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/182030446515159.png" alt="表达式模板，Expression Templates" width="500" height="304"></p>
<p>上面代码函数实现写在类的内部，即内联，如果编译器对内联支持的好的话，上面代码几乎等价于如下代码：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt; </span><span style="color: green;">// std::cout
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;cmath&gt;    </span><span style="color: green;">// std::sqrt()

</span><span style="color: blue;">void </span><span style="color: black;">evaluate(</span><span style="color: blue;">double </span><span style="color: gray;">start</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">end</span><span style="color: black;">, </span><span style="color: blue;">double </span><span style="color: gray;">step</span><span style="color: black;">) {
    </span><span style="color: blue;">double </span><span style="color: black;">_temp = 1.0;
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">double </span><span style="color: black;">i=</span><span style="color: gray;">start</span><span style="color: black;">; i&lt;</span><span style="color: gray;">end</span><span style="color: black;">; i+=</span><span style="color: gray;">step</span><span style="color: black;">)
        std::cout &lt;&lt; -i / std::sqrt(_temp + i) &lt;&lt; </span><span style="color: #a31515;">' '</span><span style="color: black;">;
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    evaluate(0.0, 10.0, 1.0);
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">-0 -0.707107 -1.1547 -1.5 -1.78885 -2.04124 -2.26779 -2.47487 -2.66667 -2.84605</span></pre>
<p>和表达式模板类似的技术还可以用到向量计算中，以避免产生临时向量变量，见文献[4] Expression templates 和文献[12]的后面。传统向量计算如下：</p>
<pre class="code-cpp"><span style="color: blue;">class </span><span style="color: #2b91af;">DoubleVec</span><span style="color: black;">; </span><span style="color: green;">// DoubleVec 重载了 + - * / 等向量元素之间的计算
</span><span style="color: #2b91af;">DoubleVec </span><span style="color: black;">y(1000), a(1000), b(1000), c(1000), d(1000); </span><span style="color: green;">// 向量长度 1000
// 向量计算
</span><span style="color: black;">y = (a + b) / (c - d);
</span><span style="color: green;">// 等价于
</span><span style="color: #2b91af;">DoubleVec </span><span style="color: black;">__t1 = a + b;
</span><span style="color: #2b91af;">DoubleVec </span><span style="color: black;">__t2 = c - d;
</span><span style="color: #2b91af;">DoubleVec </span><span style="color: black;">__t3 = __t1 / __t2;
y = __t3;</span></pre>
<p>模板代码实现向量计算如下：</p>
<pre class="code-cpp"><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">&gt; DVExpr;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">DVec</span><span style="color: black;">{
    </span><span style="color: green;">// ...
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;
    </span><span style="color: #2b91af;">DVec</span><span style="color: black;">&amp; operator=(</span><span style="color: blue;">const </span><span style="color: black;">DVExpr&lt;</span><span style="color: #2b91af;">A</span><span style="color: black;">&gt;&amp;); </span><span style="color: green;">// 由 = 引起向量逐个元素的表达式值计算并赋值
</span><span style="color: black;">};
</span><span style="color: #2b91af;">DVec </span><span style="color: black;">y(1000), a(1000), b(1000), c(1000), d(1000); </span><span style="color: green;">// 向量长度 1000
// 向量计算
</span><span style="color: black;">y = (a + b) / (c - d);
</span><span style="color: green;">// 等价于
</span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i=0; i&lt;1000; ++i) {
    y[i] = (a[i] + b[i]) / (c[i] + d[i]);
}</span></pre>
<p>不过值得一提的是，传统代码可以用 C++11 的右值引用提升性能，C++11 新特性我们以后再详细讨论。</p>
<p>我们这里看下文献[4] Expression templates 实现的版本，它用到了<span style="color: #ff0000;"><strong>编译期多态</strong></span>，编译期多态示意代码如下（关于这种代码形式有个名字叫 curiously recurring template pattern， CRTP，见文献[4]）：</p>
<pre class="code-cpp"><span style="color: green;">// 模板基类，定义接口，具体实现由模板参数，即子类实现
</span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">D</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">base </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">void </span><span style="color: black;">f1() { </span><span style="color: blue;">static_cast</span><span style="color: black;">&lt;E&amp;&gt;(*</span><span style="color: blue;">this</span><span style="color: black;">).f1(); } </span><span style="color: green;">// 直接调用子类实现
    </span><span style="color: blue;">int </span><span style="color: black;">f2() </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">static_cast</span><span style="color: black;">&lt;</span><span style="color: blue;">const </span><span style="color: black;">E&amp;&gt;(*</span><span style="color: blue;">this</span><span style="color: black;">).f1(); }
};
</span><span style="color: green;">// 子类
</span><span style="color: blue;">class </span><span style="color: #2b91af;">dirived1 </span><span style="color: black;">: </span><span style="color: blue;">public </span><span style="color: #2b91af;">base</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">dirived1</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">void </span><span style="color: black;">f1() { </span><span style="color: green;">/* ... */ </span><span style="color: black;">}
    </span><span style="color: blue;">int </span><span style="color: black;">f2() </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: green;">/* ... */ </span><span style="color: black;">}
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">dirived2 </span><span style="color: black;">: </span><span style="color: blue;">public </span><span style="color: #2b91af;">base</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">dirived2</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">void </span><span style="color: black;">f1() { </span><span style="color: green;">/* ... */ </span><span style="color: black;">}
    </span><span style="color: blue;">int </span><span style="color: black;">f2() </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: green;">/* ... */ </span><span style="color: black;">}
};</span></pre>
<p>简化后（向量长度固定为1000，元素类型为 double）的向量计算代码如下：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt; </span><span style="color: green;">// std::cout

// A CRTP base class for Vecs with a size and indexing:
</span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">E</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">VecExpr </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">double </span><span style="color: black;">operator[](</span><span style="color: blue;">int </span><span style="color: gray;">i</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return static_cast</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E </span><span style="color: blue;">const</span><span style="color: black;">&amp;&gt;(*</span><span style="color: blue;">this</span><span style="color: black;">)[</span><span style="color: gray;">i</span><span style="color: black;">]; }
    </span><span style="color: blue;">operator </span><span style="color: #2b91af;">E </span><span style="color: blue;">const</span><span style="color: black;">&amp;() </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return static_cast</span><span style="color: black;">&lt;</span><span style="color: blue;">const </span><span style="color: #2b91af;">E</span><span style="color: black;">&amp;&gt;(*</span><span style="color: blue;">this</span><span style="color: black;">); } </span><span style="color: green;">// 向下类型转换
</span><span style="color: black;">};
</span><span style="color: green;">// The actual Vec class:
</span><span style="color: blue;">class </span><span style="color: #2b91af;">Vec </span><span style="color: black;">: </span><span style="color: blue;">public </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">Vec</span><span style="color: black;">&gt; {
    </span><span style="color: blue;">double </span><span style="color: black;">_data[1000];
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">double</span><span style="color: black;">&amp;  operator[](</span><span style="color: blue;">int </span><span style="color: gray;">i</span><span style="color: black;">) { </span><span style="color: blue;">return </span><span style="color: black;">_data[</span><span style="color: gray;">i</span><span style="color: black;">]; }
    </span><span style="color: blue;">double </span><span style="color: black;">operator[](</span><span style="color: blue;">int </span><span style="color: gray;">i</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: black;">_data[</span><span style="color: gray;">i</span><span style="color: black;">]; }
    </span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">E</span><span style="color: black;">&gt;
    </span><span style="color: #2b91af;">Vec </span><span style="color: blue;">const</span><span style="color: black;">&amp; operator=(</span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">vec</span><span style="color: black;">) {
        </span><span style="color: #2b91af;">E </span><span style="color: blue;">const</span><span style="color: black;">&amp; v = </span><span style="color: gray;">vec</span><span style="color: black;">;
        </span><span style="color: blue;">for </span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i = 0; i&lt;1000; ++i) _data[i] = v[i];
        </span><span style="color: blue;">return </span><span style="color: black;">*</span><span style="color: blue;">this</span><span style="color: black;">;
    }
    </span><span style="color: green;">// Constructors
    </span><span style="color: black;">Vec() { }
    Vec(</span><span style="color: blue;">double </span><span style="color: gray;">v</span><span style="color: black;">) { </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i=0; i&lt;1000; ++i) _data[i] = </span><span style="color: gray;">v</span><span style="color: black;">; }
};

</span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">E1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">VecDifference </span><span style="color: black;">: </span><span style="color: blue;">public </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">VecDifference</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E1</span><span style="color: black;">, </span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt; &gt; {
    </span><span style="color: #2b91af;">E1 </span><span style="color: blue;">const</span><span style="color: black;">&amp; _u; </span><span style="color: #2b91af;">E2 </span><span style="color: blue;">const</span><span style="color: black;">&amp; _v;
</span><span style="color: blue;">public</span><span style="color: black;">:
    VecDifference(</span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E1</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">u</span><span style="color: black;">, </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">v</span><span style="color: black;">) : _u(</span><span style="color: gray;">u</span><span style="color: black;">), _v(</span><span style="color: gray;">v</span><span style="color: black;">) { }
    </span><span style="color: blue;">double </span><span style="color: black;">operator[](</span><span style="color: blue;">int </span><span style="color: gray;">i</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: black;">_u[</span><span style="color: gray;">i</span><span style="color: black;">] - _v[</span><span style="color: gray;">i</span><span style="color: black;">]; }
};
</span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">E</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">VecScaled </span><span style="color: black;">: </span><span style="color: blue;">public </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">VecScaled</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E</span><span style="color: black;">&gt; &gt; {
    </span><span style="color: blue;">double </span><span style="color: black;">_alpha; </span><span style="color: #2b91af;">E </span><span style="color: blue;">const</span><span style="color: black;">&amp; _v;
</span><span style="color: blue;">public</span><span style="color: black;">:
    VecScaled(</span><span style="color: blue;">double </span><span style="color: gray;">alpha</span><span style="color: black;">, </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">v</span><span style="color: black;">) : _alpha(</span><span style="color: gray;">alpha</span><span style="color: black;">), _v(</span><span style="color: gray;">v</span><span style="color: black;">) { }
    </span><span style="color: blue;">double </span><span style="color: black;">operator[](</span><span style="color: blue;">int </span><span style="color: gray;">i</span><span style="color: black;">) </span><span style="color: blue;">const </span><span style="color: black;">{ </span><span style="color: blue;">return </span><span style="color: black;">_alpha * _v[</span><span style="color: gray;">i</span><span style="color: black;">]; }
};

</span><span style="color: green;">// Now we can overload operators:
</span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">E1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">VecDifference</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E1</span><span style="color: black;">, </span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt; </span><span style="color: blue;">const
</span><span style="color: black;">operator-(</span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E1</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">u</span><span style="color: black;">, </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">v</span><span style="color: black;">) {
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">VecDifference</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E1</span><span style="color: black;">, </span><span style="color: #2b91af;">E2</span><span style="color: black;">&gt;(</span><span style="color: gray;">u</span><span style="color: black;">, </span><span style="color: gray;">v</span><span style="color: black;">);
}
</span><span style="color: blue;">template </span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">E</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">VecScaled</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E</span><span style="color: black;">&gt; </span><span style="color: blue;">const
</span><span style="color: black;">operator*(</span><span style="color: blue;">double </span><span style="color: gray;">alpha</span><span style="color: black;">, </span><span style="color: #2b91af;">VecExpr</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E</span><span style="color: black;">&gt; </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">v</span><span style="color: black;">) {
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">VecScaled</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">E</span><span style="color: black;">&gt;(</span><span style="color: gray;">alpha</span><span style="color: black;">, </span><span style="color: gray;">v</span><span style="color: black;">);
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: #2b91af;">Vec </span><span style="color: black;">u(3), v(1); </span><span style="color: blue;">double </span><span style="color: black;">alpha=9; </span><span style="color: #2b91af;">Vec </span><span style="color: black;">y;
    y = alpha*(u - v);
    std::cout &lt;&lt; y[999] &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">18</span></pre>
<p>“alpha*(u - v)” 的类型推断过程如下图所示，其中有子类到基类的隐式类型转换：</p>
<p><img style="display: inline;" title="Expression templates" src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/182349304482957.png" alt="Expression templates" width="500" height="333"></p>
<p>这里可以看到基类的作用：提供统一的接口，让 operator- 和 operator* 可以写成统一的模板形式。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>7. 特性，策略，标签</strong></span></p>
<p>利用迭代器，我们可以实现很多通用算法，迭代器在容器与算法之间搭建了一座桥梁。求和函数模板如下：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt; </span><span style="color: green;">// std::cout
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;vector&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">iter</span><span style="color: black;">&gt;
</span><span style="color: blue;">typename </span><span style="color: #2b91af;">iter</span><span style="color: black;">::</span><span style="color: #2b91af;">value_type </span><span style="color: black;">mysum(</span><span style="color: #2b91af;">iter </span><span style="color: gray;">begin</span><span style="color: black;">, </span><span style="color: #2b91af;">iter </span><span style="color: gray;">end</span><span style="color: black;">) {
    </span><span style="color: blue;">typename </span><span style="color: #2b91af;">iter</span><span style="color: black;">::</span><span style="color: #2b91af;">value_type </span><span style="color: black;">sum(0);
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: #2b91af;">iter </span><span style="color: black;">i=</span><span style="color: gray;">begin</span><span style="color: black;">; i!=</span><span style="color: gray;">end</span><span style="color: black;">; ++i) sum += *i;
    </span><span style="color: blue;">return </span><span style="color: black;">sum;
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    std::</span><span style="color: #2b91af;">vector</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; v;
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: blue;">int </span><span style="color: black;">i = 0; i&lt;100; ++i) v.push_back(i);
    std::cout &lt;&lt; mysum(v.begin(), v.end()) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">4950</span></pre>
<p>我们想让 mysum() 对指针参数也能工作，毕竟迭代器就是模拟指针，但指针没有嵌套类型 value_type，可以定义 mysum() 对指针类型的特例，但更好的办法是在函数参数和 value_type 之间多加一层 -- <strong><span style="color: #ff0000;">特性</span></strong>（traits）（参考了文献[1]第72页，特性详见文献[1] 12.1）：</p>
<pre class="code-cpp"><span style="color: green;">// 特性，traits
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">iter</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">mytraits</span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">iter</span><span style="color: black;">::</span><span style="color: #2b91af;">value_type value_type</span><span style="color: black;">;
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">mytraits</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">*&gt;{
</span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">T value_type</span><span style="color: black;">;
};

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">iter</span><span style="color: black;">&gt;
</span><span style="color: blue;">typename </span><span style="color: #2b91af;">mytraits</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">iter</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">value_type </span><span style="color: black;">mysum(</span><span style="color: #2b91af;">iter </span><span style="color: gray;">begin</span><span style="color: black;">, </span><span style="color: #2b91af;">iter </span><span style="color: gray;">end</span><span style="color: black;">) {
    </span><span style="color: blue;">typename </span><span style="color: #2b91af;">mytraits</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">iter</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">value_type </span><span style="color: black;">sum(0);
    </span><span style="color: blue;">for</span><span style="color: black;">(</span><span style="color: #2b91af;">iter </span><span style="color: black;">i=</span><span style="color: gray;">begin</span><span style="color: black;">; i!=</span><span style="color: gray;">end</span><span style="color: black;">; ++i) sum += *i;
    </span><span style="color: blue;">return </span><span style="color: black;">sum;
}

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    </span><span style="color: blue;">int </span><span style="color: black;">v[4] = {1,2,3,4};
    std::cout &lt;&lt; mysum(v, v+4) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">10</span></pre>
<p>其实，C++ 标准定义了类似的 traits：std::iterator_trait（另一个经典例子是 std::numeric_limits） 。特性对类型的信息（如 value_type、 reference）进行包装，使得上层代码可以以统一的接口访问这些信息。C++ 模板元编程会涉及大量的类型计算，很多时候要提取类型的信息（typedef、 常量值等），如果这些类型的信息的访问方式不一致（如上面的迭代器和指针），我们将不得不定义特例，这会导致大量重复代码的出现（另一种代码膨胀），而通过加一层特性可以很好的解决这一问题。另外，特性不仅可以对类型的信息进行包装，还可以提供更多信息，当然，因为加了一层，也带来复杂性。特性是一种提供元信息的手段。</p>
<p><span style="color: #ff0000;"><strong>策略</strong></span>（policy）一般是一个类模板，典型的策略是 STL 容器（如 std::vector&lt;&gt;，完整声明是template&lt;class T, class Alloc=allocator&lt;T&gt;&gt; class vector;）的分配器（这个参数有默认参数，即默认存储策略），策略类将模板的经常变化的那一部分子功能块集中起来作为模板参数，这样模板便可以更为通用，这和特性的思想是类似的（详见文献[1] 12.3）。</p>
<p><strong><span style="color: #ff0000;">标签</span></strong>（tag）一般是一个空类，其作用是作为一个独一无二的类型名字用于标记一些东西，典型的例子是 STL 迭代器的五种类型的名字（input_iterator_tag, output_iterator_tag, forward_iterator_tag, bidirectional_iterator_tag, random_access_iterator_tag），std::vector&lt;int&gt;::iterator::iterator_category 就是 random_access_iterator_tag，可以用第1节判断类型是否等价的模板检测这一点：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;vector&gt;

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; </span><span style="color: green;">// 通例，返回 false
</span><span style="color: blue;">class </span><span style="color: #2b91af;">theSameType       </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">false </span><span style="color: black;">}; };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;               </span><span style="color: green;">// 特例，两类型相同时返回 true
</span><span style="color: blue;">class </span><span style="color: #2b91af;">theSameType</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">true </span><span style="color: black;">}; };

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    std::cout &lt;&lt; </span><span style="color: #2b91af;">theSameType</span><span style="color: black;">&lt; std::</span><span style="color: #2b91af;">vector</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">iterator</span><span style="color: black;">::</span><span style="color: #2b91af;">iterator_category</span><span style="color: black;">,
                              std::</span><span style="color: #2b91af;">random_access_iterator_tag </span><span style="color: black;">&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">1</span></pre>
<p>有了这样的判断，还可以根据判断结果做更复杂的元编程逻辑（如一个算法以迭代器为参数，根据迭代器标签进行特例化以对某种迭代器特殊处理）。标签还可以用来分辨函数重载，第5节中就用到了这样的标签（recursion）（标签详见文献[1] 12.1）。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>8. 更多类型计算</strong></span></p>
<p>在第1节我们讲类型等价的时候，已经见到了一个可以判断两个类型是否等价的模板，这一节我们给出更多例子，下面是判断一个类型是否可以隐式转换到另一个类型的模板（参考了文献[6] Static interface checking）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt; </span><span style="color: green;">// std::cout

// whether T could be converted to U
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">class </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">class </span><span style="color: #2b91af;">U</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">ConversionTo </span><span style="color: black;">{
    </span><span style="color: blue;">typedef char </span><span style="color: #2b91af;">Type1</span><span style="color: black;">[1]; </span><span style="color: green;">// 两种 sizeof 不同的类型
    </span><span style="color: blue;">typedef char </span><span style="color: #2b91af;">Type2</span><span style="color: black;">[2];
    </span><span style="color: blue;">static </span><span style="color: #2b91af;">Type1</span><span style="color: black;">&amp; Test( </span><span style="color: #2b91af;">U </span><span style="color: black;">); </span><span style="color: green;">// 较下面的函数，因为参数取值范围小，优先匹配
    </span><span style="color: blue;">static </span><span style="color: #2b91af;">Type2</span><span style="color: black;">&amp; Test(...); </span><span style="color: green;">// 变长参数函数，可以匹配任何数量任何类型参数
    </span><span style="color: blue;">static </span><span style="color: #2b91af;">T </span><span style="color: black;">MakeT(); </span><span style="color: green;">// 返回类型 T，用这个函数而不用 T() 因为 T 可能没有默认构造函数
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">sizeof</span><span style="color: black;">(Test(MakeT()))==</span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: #2b91af;">Type1</span><span style="color: black;">) }; </span><span style="color: green;">// 可以转换时调用返回 Type1 的 Test()
</span><span style="color: black;">};

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    std::cout &lt;&lt; </span><span style="color: #2b91af;">ConversionTo</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">ConversionTo</span><span style="color: black;">&lt;</span><span style="color: blue;">float</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">*&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">ConversionTo</span><span style="color: black;">&lt;</span><span style="color: blue;">const int</span><span style="color: black;">&amp;, </span><span style="color: blue;">int</span><span style="color: black;">&amp;&gt;::</span><span style="color: #2f4f4f;">ret </span><span style="color: black;">&lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">1
0
0</span></pre>
<p>下面这个例子检查某个类型是否含有某个嵌套类型定义（参考了文献[4] Substitution failure is not an erro (SFINAE)），这个例子是个内省（反射的一种）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;
</span><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;vector&gt;

</span><span style="color: green;">// thanks to Substitution failure is not an erro (SFINAE)
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">struct </span><span style="color: #2b91af;">has_typedef_value_type </span><span style="color: black;">{
    </span><span style="color: blue;">typedef char </span><span style="color: #2b91af;">Type1</span><span style="color: black;">[1];
    </span><span style="color: blue;">typedef char </span><span style="color: #2b91af;">Type2</span><span style="color: black;">[2];
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">&gt; </span><span style="color: blue;">static </span><span style="color: #2b91af;">Type1</span><span style="color: black;">&amp; test(</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">::</span><span style="color: #2b91af;">value_type</span><span style="color: black;">*);
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">static </span><span style="color: #2b91af;">Type2</span><span style="color: black;">&amp; test(...);
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static const bool </span><span style="color: black;">ret = </span><span style="color: blue;">sizeof</span><span style="color: black;">(test&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;(0)) == </span><span style="color: blue;">sizeof</span><span style="color: black;">(</span><span style="color: #2b91af;">Type1</span><span style="color: black;">); </span><span style="color: green;">// 0 == NULL
</span><span style="color: black;">};

</span><span style="color: blue;">struct </span><span style="color: #2b91af;">foo </span><span style="color: black;">{ </span><span style="color: blue;">typedef float </span><span style="color: #2b91af;">lalala</span><span style="color: black;">; };

</span><span style="color: blue;">int </span><span style="color: black;">main() {
    std::cout &lt;&lt; </span><span style="color: #2b91af;">has_typedef_value_type</span><span style="color: black;">&lt;std::</span><span style="color: #2b91af;">vector</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt;&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">has_typedef_value_type</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">foo</span><span style="color: black;">&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">1
0</span></pre>
<p>这个例子是有缺陷的，因为不存在引用的指针，所以不用用来检测引用类型定义。可以看到，因为只涉及类型推断，都是编译期的计算，不涉及任何可执行代码，所以类的成员函数根本不需要具体实现。</p>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>9. 元容器</strong></span></p>
<p>文献[1]第 13 章讲了元容器，所谓元容器，就是类似于 std::vector&lt;&gt; 那样的容器，不过它存储的是元数据 -- 类型，有了元容器，我们就可以判断某个类型是否属于某个元容器之类的操作。</p>
<p>在讲元容器之前，我们先来看看<span style="color: #ff0000;"><strong>伪变长参数模板</strong></span>（文献[1] 12.4），一个可以存储小于某个数（例子中为 4 个）的任意个数，任意类型数据的元组（tuple）的例子如下（参考了文献[1] 第 225~227 页）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;

</span><span style="color: blue;">class </span><span style="color: #2b91af;">null_type </span><span style="color: black;">{}; </span><span style="color: green;">// 标签类，标记参数列表末尾
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">type_shift_node </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">T0 data_type</span><span style="color: black;">;
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">type_shift_node</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: #2b91af;">T3</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">next_type</span><span style="color: black;">; </span><span style="color: green;">// 参数移位了
    </span><span style="color: blue;">static const int </span><span style="color: black;">num = </span><span style="color: #2b91af;">next_type</span><span style="color: black;">::num + 1; </span><span style="color: green;">// 非 null_type 模板参数个数
    </span><span style="color: #2b91af;">data_type </span><span style="color: black;">data; </span><span style="color: green;">// 本节点数据
    </span><span style="color: #2b91af;">next_type </span><span style="color: black;">next; </span><span style="color: green;">// 后续所有节点数据
    </span><span style="color: black;">type_shift_node() :data(), next() { } </span><span style="color: green;">// 构造函数
    </span><span style="color: black;">type_shift_node(</span><span style="color: #2b91af;">T0 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d0</span><span style="color: black;">, </span><span style="color: #2b91af;">T1 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d2</span><span style="color: black;">, </span><span style="color: #2b91af;">T3 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d3</span><span style="color: black;">)
        :data(</span><span style="color: gray;">d0</span><span style="color: black;">), next(</span><span style="color: gray;">d1</span><span style="color: black;">, </span><span style="color: gray;">d2</span><span style="color: black;">, </span><span style="color: gray;">d3</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">()) { } </span><span style="color: green;">// next 参数也移位了
</span><span style="color: black;">};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">&gt; </span><span style="color: green;">// 特例，递归终止
</span><span style="color: blue;">class </span><span style="color: #2b91af;">type_shift_node</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">T0 data_type</span><span style="color: black;">;
    </span><span style="color: blue;">static const int </span><span style="color: black;">num = 1;
    </span><span style="color: #2b91af;">data_type </span><span style="color: black;">data; </span><span style="color: green;">// 本节点数据
    </span><span style="color: black;">type_shift_node() :data(), next() { } </span><span style="color: green;">// 构造函数
    </span><span style="color: black;">type_shift_node(</span><span style="color: #2b91af;">T0 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d0</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">, </span><span style="color: #2b91af;">null_type</span><span style="color: black;">) : data(</span><span style="color: gray;">d0</span><span style="color: black;">) { }
};
</span><span style="color: green;">// 元组类模板，默认参数 + 嵌套递归
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">=</span><span style="color: #2b91af;">null_type</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">=</span><span style="color: #2b91af;">null_type</span><span style="color: black;">,
         </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T3</span><span style="color: black;">=</span><span style="color: #2b91af;">null_type</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">my_tuple </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">type_shift_node</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">tuple_type</span><span style="color: black;">;
    </span><span style="color: blue;">static const int </span><span style="color: black;">num = </span><span style="color: #2b91af;">tuple_type</span><span style="color: black;">::num;
    </span><span style="color: #2b91af;">tuple_type </span><span style="color: black;">t;
    my_tuple(</span><span style="color: #2b91af;">T0 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d0</span><span style="color: black;">=</span><span style="color: #2b91af;">T0</span><span style="color: black;">(),</span><span style="color: #2b91af;">T1 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d1</span><span style="color: black;">=</span><span style="color: #2b91af;">T1</span><span style="color: black;">(),</span><span style="color: #2b91af;">T2 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d2</span><span style="color: black;">=</span><span style="color: #2b91af;">T2</span><span style="color: black;">(),</span><span style="color: #2b91af;">T3 </span><span style="color: blue;">const</span><span style="color: black;">&amp; </span><span style="color: gray;">d3</span><span style="color: black;">=</span><span style="color: #2b91af;">T3</span><span style="color: black;">())
        : t(</span><span style="color: gray;">d0</span><span style="color: black;">, </span><span style="color: gray;">d1</span><span style="color: black;">, </span><span style="color: gray;">d2</span><span style="color: black;">, </span><span style="color: gray;">d3</span><span style="color: black;">) { } </span><span style="color: green;">// 构造函数，默认参数
</span><span style="color: black;">};

</span><span style="color: green;">// 为方便访问元组数据，定义 get&lt;unsigned&gt;(tuple) 函数模板
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">unsigned </span><span style="color: black;">i, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">type_shift_node_traits </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef typename
        </span><span style="color: #2b91af;">type_shift_node_traits</span><span style="color: black;">&lt;i-1,</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">node_type</span><span style="color: black;">::</span><span style="color: #2b91af;">next_type node_type</span><span style="color: black;">;
    </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">node_type</span><span style="color: black;">::</span><span style="color: #2b91af;">data_type data_type</span><span style="color: black;">;
    </span><span style="color: blue;">static </span><span style="color: #2b91af;">node_type</span><span style="color: black;">&amp; get_node(</span><span style="color: #2b91af;">type_shift_node</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">node</span><span style="color: black;">)
    { </span><span style="color: blue;">return </span><span style="color: #2b91af;">type_shift_node_traits</span><span style="color: black;">&lt;i-1,</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;::get_node(</span><span style="color: gray;">node</span><span style="color: black;">).next; }
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">type_shift_node_traits</span><span style="color: black;">&lt;0, </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">type_shift_node</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">node_type</span><span style="color: black;">;
    </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">node_type</span><span style="color: black;">::</span><span style="color: #2b91af;">data_type data_type</span><span style="color: black;">;
    </span><span style="color: blue;">static </span><span style="color: #2b91af;">node_type</span><span style="color: black;">&amp; get_node(</span><span style="color: #2b91af;">type_shift_node</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">node</span><span style="color: black;">)
    { </span><span style="color: blue;">return </span><span style="color: gray;">node</span><span style="color: black;">; }
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">unsigned </span><span style="color: black;">i, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;
</span><span style="color: blue;">typename </span><span style="color: #2b91af;">type_shift_node_traits</span><span style="color: black;">&lt;i,</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;::</span><span style="color: #2b91af;">data_type
</span><span style="color: black;">get(</span><span style="color: #2b91af;">my_tuple</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;&amp; </span><span style="color: gray;">tup</span><span style="color: black;">) {
    </span><span style="color: blue;">return </span><span style="color: #2b91af;">type_shift_node_traits</span><span style="color: black;">&lt;i,</span><span style="color: #2b91af;">T0</span><span style="color: black;">,</span><span style="color: #2b91af;">T1</span><span style="color: black;">,</span><span style="color: #2b91af;">T2</span><span style="color: black;">,</span><span style="color: #2b91af;">T3</span><span style="color: black;">&gt;::get_node(</span><span style="color: gray;">tup</span><span style="color: black;">.t).data;
}

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">my_tuple</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">char</span><span style="color: black;">, </span><span style="color: blue;">float</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">tuple3</span><span style="color: black;">;
    </span><span style="color: #2b91af;">tuple3 </span><span style="color: black;">t3(10, </span><span style="color: #a31515;">'m'</span><span style="color: black;">, 1.2f);
    std::cout &lt;&lt; t3.t.data &lt;&lt; </span><span style="color: #a31515;">' '
              </span><span style="color: black;">&lt;&lt; t3.t.next.data &lt;&lt; </span><span style="color: #a31515;">' '
              </span><span style="color: black;">&lt;&lt; t3.t.next.next.data &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">tuple3</span><span style="color: black;">::num &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; get&lt;2&gt;(t3) &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; </span><span style="color: green;">// 从 0 开始，不要出现 3，否则将出现不可理解的编译错误
    </span><span style="color: black;">std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">10 m 1.2
3
1.2</span></pre>
<p>C++11 引入了变长模板参数，其背后的原理也是模板递归（文献[1]第 230 页）。</p>
<p>利用和上面例子类似的模板参数移位递归的原理，我们可以构造一个存储“类型”的元组，即<strong><span style="color: #ff0000;">元容器</span></strong>，其代码如下（和文献[1]第 237 页的例子不同）：</p>
<pre class="code-cpp"><span style="color: blue;">#include </span><span style="color: #a31515;">&lt;iostream&gt;</span>

<span style="color: green;">// 元容器</span>
<span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">=</span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">=</span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">=</span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T3</span><span style="color: black;">=</span><span style="color: blue;">void</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">meta_container </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">T0 type</span><span style="color: black;">;
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">meta_container</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: #2b91af;">T2</span><span style="color: black;">, </span><span style="color: #2b91af;">T3</span><span style="color: black;">, </span><span style="color: blue;">void</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">next_node</span><span style="color: black;">; </span><span style="color: green;">// 参数移位了
    </span><span style="color: blue;">static const int </span><span style="color: black;">size = </span><span style="color: #2b91af;">next_node</span><span style="color: black;">::size + 1; </span><span style="color: green;">// 非 null_type 模板参数个数
</span><span style="color: black;">};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;&gt; </span><span style="color: green;">// 特例，递归终止
</span><span style="color: blue;">class </span><span style="color: #2b91af;">meta_container</span><span style="color: black;">&lt;</span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: blue;">void</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef void </span><span style="color: #2b91af;">type</span><span style="color: black;">;
    </span><span style="color: blue;">static const int </span><span style="color: black;">size = 0;
};

</span><span style="color: green;">// 访问元容器中的数据
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">, </span><span style="color: blue;">unsigned </span><span style="color: black;">i&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">get </span><span style="color: black;">{
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static_assert</span><span style="color: black;">(i&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">::size, </span><span style="color: #a31515;">"get&lt;C,i&gt;: index exceed num"</span><span style="color: black;">); </span><span style="color: green;">// C++11 引入静态断言
    </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">get</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">,i-1&gt;::</span><span style="color: #2b91af;">c_type</span><span style="color: black;">::</span><span style="color: #2b91af;">next_node c_type</span><span style="color: black;">;
    </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">c_type</span><span style="color: black;">::</span><span style="color: #2b91af;">type ret_type</span><span style="color: black;">;
};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">get</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">, 0&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static_assert</span><span style="color: black;">(0&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">::size, </span><span style="color: #a31515;">"get&lt;C,i&gt;: index exceed num"</span><span style="color: black;">); </span><span style="color: green;">// C++11 引入静态断言
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">C c_type</span><span style="color: black;">;
    </span><span style="color: blue;">typedef typename </span><span style="color: #2b91af;">c_type</span><span style="color: black;">::</span><span style="color: #2b91af;">type ret_type</span><span style="color: black;">;
};

</span><span style="color: green;">// 在元容器中查找某个类型，找到返回索引，找不到返回 -1
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T2</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">same_type </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">false </span><span style="color: black;">}; };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">same_type</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">enum </span><span style="color: black;">{ ret = </span><span style="color: blue;">true </span><span style="color: black;">}; };

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">bool </span><span style="color: black;">c, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">IF_ </span><span style="color: black;">{ };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">true</span><span style="color: black;">, </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">Then reType</span><span style="color: black;">; };
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt;</span><span style="color: blue;">false</span><span style="color: black;">, </span><span style="color: #2b91af;">Then</span><span style="color: black;">, </span><span style="color: #2b91af;">Else</span><span style="color: black;">&gt; { </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">Else reType</span><span style="color: black;">; };

</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">find </span><span style="color: black;">{
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">int </span><span style="color: black;">i&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">number </span><span style="color: black;">{ </span><span style="color: blue;">public</span><span style="color: black;">: </span><span style="color: blue;">static const int </span><span style="color: black;">ret = i; };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: blue;">int </span><span style="color: black;">i&gt;
    </span><span style="color: blue;">class </span><span style="color: #2b91af;">find_i </span><span style="color: black;">{
    </span><span style="color: blue;">public</span><span style="color: black;">:
        </span><span style="color: blue;">static const int </span><span style="color: black;">ret = </span><span style="color: #2b91af;">IF_</span><span style="color: black;">&lt; </span><span style="color: #2b91af;">same_type</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">get</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">,i&gt;::</span><span style="color: #2b91af;">ret_type</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;::ret,
            </span><span style="color: #2b91af;">number</span><span style="color: black;">&lt;i&gt;, </span><span style="color: #2b91af;">find_i</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">,</span><span style="color: #2b91af;">T</span><span style="color: black;">,i-1&gt; &gt;::</span><span style="color: #2b91af;">reType</span><span style="color: black;">::ret;
    };
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">C</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
    </span><span style="color: blue;">class </span><span style="color: #2b91af;">find_i</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">, -1&gt; {
    </span><span style="color: blue;">public</span><span style="color: black;">:
        </span><span style="color: blue;">static const int </span><span style="color: black;">ret = -1;
    };
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">static const int </span><span style="color: black;">ret = </span><span style="color: #2b91af;">find_i</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">C</span><span style="color: black;">, </span><span style="color: #2b91af;">T</span><span style="color: black;">, </span><span style="color: #2b91af;">C</span><span style="color: black;">::size-1&gt;::ret;
};

</span><span style="color: blue;">int </span><span style="color: black;">main(){
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">meta_container</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&amp;, </span><span style="color: blue;">const int</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">mc</span><span style="color: black;">;
    </span><span style="color: blue;">int </span><span style="color: black;">a = 9999;
    </span><span style="color: #2b91af;">get</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">mc</span><span style="color: black;">, 1&gt;::</span><span style="color: #2b91af;">ret_type </span><span style="color: black;">aref = a;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">mc</span><span style="color: black;">::size &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; aref &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">find</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">mc</span><span style="color: black;">, </span><span style="color: blue;">const int</span><span style="color: black;">&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cout &lt;&lt; </span><span style="color: #2b91af;">find</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">mc</span><span style="color: black;">, </span><span style="color: blue;">float</span><span style="color: black;">&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">;
    std::cin.get(); </span><span style="color: blue;">return </span><span style="color: black;">0;
}</span></pre>
<pre class="console-cpp"><span style="color: black;">3
9999
2
-1</span></pre>
<p>上面例子已经实现了存储类型的元容器，和元容器上的查找算法，但还有一个小问题，就是它不能处理模板，编译器对模板的操纵能力远不如对类型的操纵能力强（提示：类模板实例是类型），我们可以一种间接方式实现存储“模板元素”，即用模板的一个代表实例（如全用 int 为参数的实例）来代表这个模板，这样对任意模板实例，只需判断其模板的代表实例是否在容器中即可，这需要进行<span style="color: #ff0000;"><strong>类型过滤</strong></span>：对任意模板的实例将其替换为指定模板参数的代表实例，类型过滤实例代码如下（参考了文献[1]第 241 页）：</p>
<pre class="code-cpp"><span style="color: green;">// 类型过滤，meta_filter 使用时只用一个参数，设置四个模板参数是因为，模板通例的参数列表
// 必须能够包含特例参数列表，后面三个参数设置默认值为 void 或标签模板
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">dummy_template_1 </span><span style="color: black;">{};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">dummy_template_2 </span><span style="color: black;">{};
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1 </span><span style="color: black;">= </span><span style="color: blue;">void</span><span style="color: black;">,
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">tmp_1 </span><span style="color: black;">= </span><span style="color: #2b91af;">dummy_template_1</span><span style="color: black;">,
    </span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">, </span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">tmp_2 </span><span style="color: black;">= </span><span style="color: #2b91af;">dummy_template_2</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">meta_filter </span><span style="color: black;">{ </span><span style="color: green;">// 通例，不改变类型
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">T0 ret_type</span><span style="color: black;">;
};
                    </span><span style="color: green;">// 匹配任何带有一个类型参数模板的实例，将模板实例替换为代表实例
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">tmp_1</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">meta_filter</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">tmp_1</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T</span><span style="color: black;">&gt;, </span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: #2b91af;">dummy_template_1</span><span style="color: black;">, </span><span style="color: #2b91af;">dummy_template_2</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">tmp_1</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">ret_type</span><span style="color: black;">;
};
                    </span><span style="color: green;">// 匹配任何带有两个类型参数模板的实例，将模板实例替换为代表实例
</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">, </span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">tmp_2</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: blue;">typename </span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt;
</span><span style="color: blue;">class </span><span style="color: #2b91af;">meta_filter</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">tmp_2</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">T0</span><span style="color: black;">, </span><span style="color: #2b91af;">T1</span><span style="color: black;">&gt;, </span><span style="color: blue;">void</span><span style="color: black;">, </span><span style="color: #2b91af;">dummy_template_1</span><span style="color: black;">, </span><span style="color: #2b91af;">dummy_template_2</span><span style="color: black;">&gt; {
</span><span style="color: blue;">public</span><span style="color: black;">:
    </span><span style="color: blue;">typedef </span><span style="color: #2b91af;">tmp_2</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt; </span><span style="color: #2b91af;">ret_type</span><span style="color: black;">;
};</span></pre>
<p>现在，只需将上面元容器和元容器查找函数修改为：对模板实例将其换为代表实例，即修改 meta_container&lt;&gt; 通例中“typedef T0 type;”语句为“typedef typename meta_filter&lt;T0&gt;::ret_type type;”，修改 find&lt;&gt; 的最后一行中“T”为“typename meta_filter&lt;T&gt;::ret_type”。修改后，下面代码的执行结果是：</p>
<pre class="code-cpp"><span style="color: blue;">template</span><span style="color: black;">&lt;</span><span style="color: blue;">typename</span><span style="color: black;">, </span><span style="color: blue;">typename</span><span style="color: black;">&gt; </span><span style="color: blue;">class </span><span style="color: #2b91af;">my_tmp_2</span><span style="color: black;">;

</span><span style="color: green;">// 自动将 my_tmp_2&lt;float, int&gt; 过滤为 my_tmp_2&lt;int, int&gt;
</span><span style="color: blue;">typedef </span><span style="color: #2b91af;">meta_container</span><span style="color: black;">&lt;</span><span style="color: blue;">int</span><span style="color: black;">, </span><span style="color: blue;">float</span><span style="color: black;">, </span><span style="color: #2b91af;">my_tmp_2</span><span style="color: black;">&lt;</span><span style="color: blue;">float</span><span style="color: black;">, </span><span style="color: blue;">int</span><span style="color: black;">&gt;&gt; </span><span style="color: #2b91af;">mc2</span><span style="color: black;">;
</span><span style="color: green;">// 自动将 my_tmp_2&lt;char, double&gt; 过滤为 my_tmp_2&lt;int, int&gt;
</span><span style="color: black;">std::cout &lt;&lt; </span><span style="color: #2b91af;">find</span><span style="color: black;">&lt;</span><span style="color: #2b91af;">mc2</span><span style="color: black;">, </span><span style="color: #2b91af;">my_tmp_2</span><span style="color: black;">&lt;</span><span style="color: blue;">char</span><span style="color: black;">, </span><span style="color: blue;">double</span><span style="color: black;">&gt;&gt;::ret &lt;&lt; </span><span style="color: #a31515;">'\n'</span><span style="color: black;">; </span><span style="color: green;">// 输出 2</span></pre>
<pre class="console-cpp"><span style="color: black;">2</span></pre>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>10. 总结</strong></span></p>
<p>博文比较长，总结一下所涉及的东西：</p>
<ul>
<li>C++ 模板包括函数模板和类模板，模板参数形式有：类型、模板型、非类型（整型、指针）；</li>
<li>模板的特例化分完全特例化和部分特例化，实例将匹配参数集合最小的特例；</li>
<li>用实例参数替换模板形式参数称为实例化，实例化的结果是产生具体类型（类模板）或函数（函数模板），同一模板实参完全等价将产生等价的实例类型或函数；</li>
<li>模板一般在头文件中定义，可能被包含多次，编译和链接时会消除等价模板实例；</li>
<li>template、typename、this 关键字用来消除歧义，避免编译错误或产生不符预期的结果；</li>
<li>C++11 对模板引入了新特性：“&gt;&gt;”、函数模板也可以有默认参数、变长模板参数、外部模板实例（extern），并弃用 export template；</li>
<li>C++ 模板是图灵完备的，模板编程是函数编程风格，特点是：没有可变的存储、递归，以“&lt;&gt;”为输入，typedef 或静态常量为输出；</li>
<li>编译期数值计算虽然实际意义不大，但可以很好证明 C++ 模板的能力，可以用模板实现类似普通程序中的 if 和 while 语句；</li>
<li>一个实际应用是循环展开，虽然编译器可以自动循环展开，但我们可以让这一切更可控；</li>
<li>C++ 模板编程的两个问题是：难调试，会产生冗长且难以阅读的编译错误信息、代码膨胀（源代码膨胀、二进制对象文件膨胀），改进的方法是：增加一些检查代码，让编译器及时报错，使用特性、策略等让模板更通用，可能的话合并一些模板实例（如将代码提出去做成单独模板）；</li>
<li>表达式模板和向量计算是另一个可加速程序的例子，它们将计算表达式编码到类型，这是通过模板嵌套参数实现的；</li>
<li>特性，策略，标签是模板编程常用技巧，它们可以是模板变得更加通用；</li>
<li>模板甚至可以获得类型的内部信息（是否有某个 typedef），这是反射中的内省，C++ 在语言层面对反射支持很少（typeid），这不利于模板元编程；</li>
<li>可以用递归实现伪变长参数模板，C++11 变长参数模板背后的原理也是模板递归；</li>
<li>元容器存储元信息（如类型）、类型过滤过滤某些类型，它们是元编程的高级特性。</li>
</ul>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>进一步学习</strong></span></p>
<p>C++ 确实比较复杂，这可能是因为，虽然 C++ 语言层次比较低，但它却同时可以实现很多高级特性。进一步学习 C++ 模板元编程的途径很多：</p>
<ul>
<li>C++ 标准库的 STL 可能是最好的学习案例，尤其是其容器、迭代器、通用算法、函数类模板等部件，实现机制很巧妙；</li>
<li>另外一个 C++ 库也值得一看，那就是 Boost 库，Boost 的元编程库参考文献[16]；</li>
<li>很推荐《深入实践C++模板编程》这本书，这篇博文大量参考了这本书；</li>
<li>wikibooks.org 上有个介绍 C++ 各种编程技巧书：More C++ Idioms，文献[15]；</li>
<li>文献[17]列了 C++ 模板的参考书，共四本；</li>
<li>好多东西，书上讲的比较浅显，而且不全面，有时候直接看 C++ 标准（最新 C++11）可能更为高效，C++ 标准并不是想象中那样难读，C++ 标准委员会网站的 Papers 也很值得看，文献[3]。</li>
</ul>
<p>&nbsp;</p>
<p><span style="font-size: large;"><strong>参考文献</strong>：</span></p>
<ol>
<li>深入实践C++模板编程，温宇杰著，2013（<a href="http://product.dangdang.com/1364954327.html">到当当网</a>）；</li>
<li>C++程序设计语言，Bjarne Stroustrup著，裘宗燕译，2002（<a href="http://product.dangdang.com/20813125.html">到当当网</a>）；</li>
<li>C++标准，ISO/IEC 14882:2003，ISO/IEC 14882:2011（<a href="http://www.iso.org/iso/catalogue_detail.htm?csnumber=50372">到ISO网站</a>，<a href="http://www.open-std.org/jtc1/sc22/wg21/">C++标准委员会</a>）；</li>
<li>wikipedia.org（<a href="http://zh.wikipedia.org/wiki/C%2B%2B#cite_note-2">C++</a>， <a href="http://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF_(C%2B%2B)">模板</a>， <a href="http://en.wikipedia.org/wiki/Template_metaprogramming">Template metaprogramming</a>， <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">Curiously recurring template pattern</a>， <a href="http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">Substitution failure is not an erro (SFINAE)</a>， <a href="http://en.wikipedia.org/wiki/Expression_templates">Expression templates</a>， <a href="http://zh.wikipedia.org/wiki/C%2B%2B11">C++11</a>， <a href="http://zh.wikipedia.org/wiki/C%2B%2B14">C++14</a>）；</li>
<li>What does a call to 'this-&gt;template [somename]' do? （<a href="http://stackoverflow.com/questions/5533354/what-does-a-call-to-this-template-somename-do">stackoverflow问答</a>）；</li>
<li>Advanced C++ Lessons，chapter 6，在线教程，2005（<a href="http://aszt.inf.elte.hu/~gsd/halado_cpp/">到网站</a>）；</li>
<li>C++ TUTORIAL - TEMPLATES - 2015，bogotobogo.com 网上教程（<a href="http://www.bogotobogo.com/cplusplus/templates.php">到网站</a>）；</li>
<li>C++ Templates are Turing Complete，Todd L. Veldhuizen，2003（作者网站已经停了，<a href="http://web.archive.org/web/20050118195822/http://osl.iu.edu/~tveldhui/papers/2003/turing.pdf">archive.org 保存的版本</a>，archive.org 可能被限制浏览）；</li>
<li>Metaprogramming in C++，Johannes Koskinen，2004（<a href="http://staff.ustc.edu.cn/~xyfeng/teaching/FOPL/lectureNotes/MetaprogrammingCpp.pdf">中科大老师保存的版本</a>）；</li>
<li>C++ Template Metaprogramming in 15ish Minutes（Stanford 课程 PPT，<a href="http://stanfordacm.com/files/Template-Metaprogramming.pdf">到网站</a>）；</li>
<li>Template Metaprograms，Todd Veldhuizen，1995（<a href="http://web.archive.org/web/20050212212917/http://osl.iu.edu/~tveldhui/">archive.org 保存 Todd Veldhuizen 主页</a>，可能限制访问，<a href="http://online2pdf.com/convert-ps-to-pdf">在线 PS 文件转 PDF 文件网站</a>）；</li>
<li>Expression Templates，Todd Veldhuizen，1995；</li>
<li>C++ Templates as Partial Evaluation，Todd Veldhuizen，1999；</li>
<li><a href="http://www.erwin-unruh.de/primorig.html">Erwin Unruh 写的第一个模板元编程程序</a>；</li>
<li>wikibooks.org（<a href="http://en.wikibooks.org/wiki/C++_Programming/Templates/Template_Meta-Programming">C++ Programming/Templates/Template Meta-Programming</a>，<a href="http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms">More C++ Idioms</a>）；</li>
<li>THE BOOST MPL LIBRARY online docs（<a href="http://www.boost.org/doc/libs/1_57_0/libs/mpl/doc/index.html">到网站</a>）；</li>
<li>Best introduction to C++ template metaprogramming?（<a href="http://stackoverflow.com/questions/112277/best-introduction-to-c-template-metaprogramming">stackoverflow问答</a>）。</li>
</ol>
<p><span style="color: #ff0000;">注：参考文献中所给的链接，打开不了的，可以参见</span><a href="http://www.cnblogs.com/liangliangh/p/4191529.html">我的另一篇博客配置浏览器</a></p>
<p>Johannes Koskinen 论文，Stanford 课程 PPT，Todd Veldhuizen 论文我网盘保存的副本 -</p>
<p>链接: <a href="http://pan.baidu.com/s/1ntJstvF">http://pan.baidu.com/s/1ntJstvF</a> 密码: hogb</p>
<p>&nbsp;</p>
<p>&nbsp; &nbsp;&nbsp;</p></div><div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
<div id="BlogPostCategory"></div>
<div id="EntryTag"></div>
<div id="blog_post_info">
</div>
<div class="clear"></div>
<div id="post_next_prev"></div>
</div>

</div>
		<p class="postfoot">
			posted on <span id="post-date">2015-01-21 14:53</span> <a href="http://www.cnblogs.com/liangliangh/">liangliangh</a> 阅读(<span id="post_view_count">...</span>) 评论(<span id="post_comment_count">...</span>)  <a href="http://i.cnblogs.com/EditPosts.aspx?postid=4219879" rel="nofollow">编辑</a> <a href="http://www.cnblogs.com/liangliangh/p/4219879.html#" onclick="AddToWz(4219879);return false;">收藏</a>
		</p>
	</div>
	<script type="text/javascript">var allowComments=true,isLogined=false,cb_blogId=151287,cb_entryId=4219879,cb_blogApp=currentBlogApp,cb_blogUserGuid='21c12945-41bc-e211-b39b-90b11c0b1faa',cb_entryCreatedDate='2015/1/21 14:53:00';loadViewCount(cb_entryId);</script>
	
	<a name="!comments"></a><div id="blog-comments-placeholder"><div style="color:green;margin:50px 0;font-weight:bold;">努力加载评论中...</div></div><script type="text/javascript">var commentManager = new blogCommentManager();commentManager.renderComments(0);</script>
<div id="comment_form" class="commentform">
<a name="commentform"></a>
<div id="divCommentShow"></div>
<div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" id="lnk_RefreshComments" onclick="return RefreshCommentList();">刷新评论</a><a href="http://www.cnblogs.com/liangliangh/p/4219879.html#" onclick="return RefreshPage();">刷新页面</a><a href="http://www.cnblogs.com/liangliangh/p/4219879.html#top">返回顶部</a></div>
<div id="comment_form_container"></div>
<div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
<div id="site_nav_under"><a href="http://www.cnblogs.com/" target="_blank" title="开发者的网上家园">博客园首页</a><a href="http://q.cnblogs.com/" target="_blank" title="程序员问答社区">博问</a><a href="http://news.cnblogs.com/" target="_blank" title="IT新闻">新闻</a><a href="http://home.cnblogs.com/ing/" target="_blank">闪存</a><a href="http://job.cnblogs.com/" target="_blank">程序员招聘</a><a href="http://kb.cnblogs.com/" target="_blank">知识库</a></div>
<div id="opt_under_post"></div>
<script type="text/javascript">
    var enableGoogleAd = canShowAdsense(); 
    fixPostBodyFormat();
</script>
<script type="text/javascript">
  var googletag = googletag || {};
  googletag.cmd = googletag.cmd || [];
    (function () {
        if (enableGoogleAd) {
            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';
            var useSSL = 'https:' == document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') +
              '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);
        }
  })();
</script>
<script type="text/javascript">
    try {
        if (enableGoogleAd) {
            googletag.cmd.push(function() {
            googletag.defineSlot('/1090369/cnblogs_blogpost_C2', [468, 60], 'div-gpt-ad-1433581717989-0').addService(googletag.pubads());
            googletag.defineSlot('/1090369/cnblogs_blogpost_C1_sitehome', [300, 250], 'div-gpt-ad-1433581717989-1').addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.pubads().collapseEmptyDivs();
            googletag.enableServices();
            });
        };
    } catch (e) { }
</script>
<div id="google_ad_c1" class="c_ad_block">
    <div id="div-gpt-ad-1433581717989-1" style="height:250px; width:300px;">
    <script type="text/javascript">
        try {
            if (enableGoogleAd) {
                googletag.cmd.push(function () { googletag.display('div-gpt-ad-1433581717989-1'); });
            } else {
                $('#div-gpt-ad-1433581717989-1').hide();
            }
    } catch (e) { }
    </script>
    </div>
</div>
<div id="under_post_news"></div>
<div id="google_ad_c2" class="c_ad_block">
<div id="div-gpt-ad-1433581717989-0" style="height:60px; width:468px;">
<script type="text/javascript">
try {
    if (enableGoogleAd) {
        googletag.cmd.push(function () { googletag.display('div-gpt-ad-1433581717989-0'); });
    } else {
        $('#div-gpt-ad-1433581717989-0').hide();
    }
} catch (e) { }
</script>
</div>
</div>
<div id="under_post_kb"></div>
<div id="HistoryToday" class="c_ad_block"></div>
<script type="text/javascript">
$(function () {
    loadNewsAndKb();
    loadBlogSignature();
    LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
    GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate);
    loadOptUnderPost();
    GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    setTimeout(function () { incrementViewCount(cb_entryId); }, 200);
});
</script>
</div>
    
</div>
<div id="rightmenu">
    
        
<h3>公告</h3>
	<div id="blog-news"></div><script type="text/javascript">loadBlogNews();</script>

        
<h3>导航</h3>
<ul>
			<li><a id="MyLinks1_HomeLink" href="http://www.cnblogs.com/">博客园</a></li>
			<li><a id="MyLinks1_MyHomeLink" href="http://www.cnblogs.com/liangliangh/">首页</a></li>
			<li></li>
			<li><a id="MyLinks1_ContactLink" accesskey="9" rel="nofollow" href="http://msg.cnblogs.com/send/liangliangh">联系</a></li>
			<li><a id="MyLinks1_Syndication" href="http://www.cnblogs.com/liangliangh/rss">订阅</a><a id="MyLinks1_XMLLink" href="http://www.cnblogs.com/liangliangh/rss"><img src="./C++模板元编程（C++ template metaprogramming） - liangliangh - 博客园_files/xml.gif" alt="订阅"></a>
			</li><li><a id="MyLinks1_Admin" rel="nofollow" href="http://i.cnblogs.com/">管理</a></li>
</ul>
        <div id="blog-calendar" style="display:none"></div><script type="text/javascript">loadBlogDefaultCalendar();</script>
        
<h3>统计</h3>
	<ul>
		<li>随笔 - 28
		</li><li>文章 - 0
		</li><li>评论 - 116
		</li><li>引用 - 0
	</li>
</ul>
        <div id="blog-sidecolumn"></div><script type="text/javascript">loadBlogSideColumn();</script>
    
</div>
</div>
<div class="clear"></div>

<div id="footer">
	Powered by: 
	<a id="Footer1_Hyperlink3" name="Hyperlink1" href="http://www.cnblogs.com/" style="font-family:Verdana;font-size:12px;">博客园</a>	Copyright © liangliangh
</div>



</body></html>